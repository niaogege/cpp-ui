---
title: web缓存
order: 3
group:
  order: 10
  title: browser
  path: /interview/browser
nav:
  order: 3
  title: 'interview'
  path: /interview
---

## web 缓存

web 缓存主要指的是两部分：浏览器缓存和 http 缓存。

其中 http 缓存是 web 缓存的核心，是最难懂的那一部分,也是最重要的那一部分。

浏览器缓存：比如 localStorage,sessionStorage,cookie 等等。这些功能主要用于缓存一些必要的数据，比如用户信息。比如需要携带到后端的参数。亦或者是一些列表数据等等。浏览器缓存优先级：

- memory cache 内存缓存,读取内存中的数据,速度最快，但缓存可持续性会很短，会随着进程的释放而释放，一旦我们关闭 Tab 页面，内存中的缓存也就被释放了

- service worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能

- Disk Cache 磁盘缓存 读取速度慢一点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上，相同地址的资源一旦被缓存起来，就不会再次请求数据，主要是根据 http 中的 Header 来判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求

- Push Cache Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放

不过这里需要注意。像 localStorage，sessionStorage 这种用户缓存数据的功能，他只能保存 5M 左右的数据，多了不行。cookie 则更少，大概只能有 4kb 的数据

## http 缓存

> 注意，我们的缓存主要是针对 html,css,img 等静态资源，常规情况下，我们不会去缓存一些动态资源(比如接口)，因为缓存动态资源的话，数据的实时性就不会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源。

- 缓存解决的问题

减少不必要的网络传输，节约宽带（就是省钱）

更快的加载页面（就是加速）

减少服务器负载，避免服务器过载的情况出现。（就是减载）

- 缺点

占内存（有些缓存会被存到内存中）

### http 之强缓存

http 缓存分为两种缓存，强制缓存和协商缓存, 我们来深度剖析一下强制缓存和协商缓存各自的优劣以及他们的使用场景以及使用原理

强制缓存：从强制缓存的角度触发，如果浏览器判断请求的目标资源有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯。

#### 基于 Expires 字段实现的强缓存

Expires 字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。

比如说将某一资源设置响应头为:Expires:new Date("2022-7-30 23:59:59")；

因为 Expires 判断强缓存是否过期的机制是:**获取本地时间戳**，并对先前拿到的资源文件中的 Expires 字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”

是的，Expires 过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，Expires 字段几乎不被使用了。现在的项目中，我们并不推荐使用 Expires，强缓存功能通常使用**cache-control**字段来代替 Expires 字段。

#### 基于 Cache-control 实现的强缓存（代替 Expires 的强缓存实现方法）

Cache-control 这个字段在 http1.1 中被增加，Cache-control 完美解决了 Expires 本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。

Cache-control 的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒。比如 ↓

```js
//往响应头中写入需要缓存的时间
res.writeHead(200, {
  'Cache-Control': 'max-age=100',
});
```

从该资源第一次返回的时候开始，往后的**100 秒钟内**如果该资源被再次请求，则从缓存中读取。

Cache-Control:**max-age=N**，N 就是需要缓存的秒数。从第一次请求资源的时候开始，往后 N 秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。

Cache-control 有 max-age、s-maxage、no-cache、no-store、private、public 这六个属性。

#### max-age/s-maxage

max-age 决定客户端资源被缓存多久。 s-maxage 决定代理服务器缓存的时长。

max-age 表示的时间资源在客户端缓存的时长，而 s-maxage 表示的是资源在代理服务器可以缓存的时长。

在一般的项目架构中 max-age 就够用。

> 注意，max-age 和 s-maxage 并不互斥。他们可以一起使用。

而 s-maxage 因为是代理服务端的缓存时长，他必须和上面说的 public 属性一起使用（public 属性表示资源可以在代理服务器中缓存）。

#### no-cache/no-store

no-cache 表示是强制进行**协商缓存**。 no-store 是表示禁止任何缓存策略。

> 而 s-maxage 因为是代理服务端的缓存时长，他必须和上面说的 public 属性一起使用（public 属性表示资源可以在代理服务器中缓存）。

#### pubic/private

public 表示资源即可以被浏览器缓存也可以被代理服务器缓存。 private 表示资源只能被浏览器缓存。

而 public 和 private 就是决定资源是否可以在代理服务器进行缓存的属性。

其中，public 表示资源在客户端和代理服务器都可以被缓存。

private 则表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存。

如果这两个属性值都没有被设置，则**默认为 private**

> 注意，public 和 private 也是一组互斥属性。他们两个不能同时出现在响应头的 cache-control 字段中。

### http 之协商缓存

#### 基于 last-modified 的协商缓存

基于 last-modified 的协商缓存实现方式是:

- 首先需要在服务器端读出文件修改时间，

- 将读出来的修改时间赋给响应头的 last-modified 字段。

- 最后设置 Cache-control:no-cache

当客户端读取到**last-modified**的时候，会在下次的请求标头中携带一个字段:**If-Modified-Since**。而这个请求头中的 If-Modified-Since 的值就是服务器第一次修改时候给他的时间；

那么之后每次对该资源的请求，都会带上 If-Modified-Since 这个字段，而服务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。

last-modified 和 if-Modified-Since 缺点 1.因为是根据文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。

2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件

了解决上述的这两个问题。从 http1.1 开始新增了一个头信息，ETag

#### Etag/if-none-match

ETag 就是将原先协商缓存的比较时间戳的形式修改成了比较**文件指纹**。

> 文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。

我们来看一下流程 ↓

1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在**响应头的 etag**字段中跟资源一起返回给客户端。

2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的 ETag 也就是文件指纹。并赋给请求头的**if-None-Match**字段，让上一次的文件指纹跟随请求一起回到服务端。

3.服务端拿到请求头中的 is-None-Match 字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回**304 状态码**和一个空的响应体并 return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的 ETag 中并返回给客户端

#### ETag 也有缺点

- ETag 需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么 ETag 的计算就会影响服务器的性能。显然，ETag 在这样的场景下就不是很适合。

- ETag 有强验证和弱验证，所谓将强验证，ETag 生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag 还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。

### 总结一下

http 缓存可以减少宽带流量，加快响应速度。

关于强缓存，**cache-control 是 Expires 的完全替代方案**，在可以使用 cache-control 的情况下不要使用 expires

关于协商缓存,etag 并不是 last-modified 的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。

- 响应状态码 304 的资源都是协商缓存

- 标注(从内存中读取/从磁盘中读取)的资源都是强缓存

### 参考

- [中高级前端工程师都需要熟悉的技能--前端缓存](https://mp.weixin.qq.com/s/O4C3hlO6tYV6qiIwgQXhEA)
