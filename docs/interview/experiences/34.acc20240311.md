---
title: 20240311积累面试
order: 34
group:
  order: 0
  title: interview
nav:
  order: 3
  title: 'interview'
  path: /interview
---

- 手写嵌套对象扁平化支持传递参数深度
- 手写 promise
- 手写图片懒加载，placeholder 如何初始化
- react 中的 fiber 架构是如何异步更新的
- react 中的 diff 算法和策略(算法不知道)
- vue 跟 react 区别
- 虚拟 dom 原理
- node 如何做负载均衡?
- opacity/display/opacity 区别(忘记区别了)
- xss 和 csrf 跨站脚本攻击和跨站请求伪造
- 前端性能优化
- 浏览器缓存，cache-control
- js 事件循环机制
- url 加载
- 重绘和重排
- 项目中有难度的说一说

> 自我感觉一般般,第一道题写了一半，那个深度的传参，真想不出来啊，最荒诞的时候 我首次还能写出来。面的内容够杂也够多，基本上能问的都问了个遍，面试官也是厉害，周到，全面，啥都要问问

> 除了 node 和 react diff 算法没答出来 其他的都是表面，需要自己多组织语言，多练习，多说

## 嵌套对象扁平化支持传递参数深度

```js
function flatten(arr, depth) {
  let stack = [...arr];
  let ans = [];
  let i = 0;
  while (stack.length) {
    let cur = stack.pop();
    if (Array.isArray(cur) && i < depth) {
      i++;
      stack.push(...cur);
    } else {
      ans.push(cur);
    }
  }
  return ans.reverse();
}
```

## 手写 promise

```js
class Promise {
  constructor() {}
  then(onFulfull) {}
}
```

## 前端在谈性能优化

这个题目必考，你在项目里是如何进行性能优化的？如何给人一种不错的印象？

### js/css

- 将 CSS 放在文件头部，JavaScript 文件放在底部
- 合理使用 async/defer 加载和解析脚本
- 使用 flex 布局 减少使用老的 table 布局
- 使用 transform 和 opacity 属性更改来实现动画
- 减少重排重绘
- 使用 requestAnimationFrame 优化动画，防止页面动画卡顿
- 时间切片,时间切片是一种将长时间运行的任务分解成多个小任务的技术，从而避免阻塞主线程，提高页面的响应速度和用户体验。时间切片可以使用**requestIdleCallback** API 来实现，该 API 会在浏览器空闲时执行回调函数
- 使用事件委托，节省内存空间
- 并发请求 Promise.all,可以使用并发请求来提高页面的加载速度和用户体验

### 构建工具

- webpack 按需加载，
- tree shaking
- 提取第三方库，比如不怎么变的 react/react-dom
- split code

### 网络相关

- 减少 HTTP 请求
- 使用 http2
- cdn
- gzip
- preload/prefetch
- 善用/合理利用浏览器缓存
- 图片优化，压缩大小，webp,图片懒加载

### 框架层面

- 引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节,只关注业务本身
- 父组件更新，不波及子组件渲染，没有必要的渲染是对性能的极大浪费。合理使用 react.memo/useMemo/useCallback/shouldComponentUpdate/PureComponent
- 遍历数组的时候，记得加上唯一的标记 key

### 针对做过的项目性能优化

- 组件优化 nextjs 中有个动态引入组件，对于不需要直出的组件阔以用

## 再谈 vue 和 react 区别

个人使用上： react 推崇函数式编程，主持纯函数，单向数据流，jsx 语法自由灵活

### 设计思想/语法/diff 算法/生态

### 响应式原理

Vue 是对数据进行劫持/代理，它对监测数据的变化更加精准，动了多少数据就触发多少更新，更新粒度很小，而 React 推崇函数式，这是没办法感知数据变化的，就是说不知道什么时候应该刷新，而且即便是手动 setState 触发更新，它也也不知道哪些组件需要刷新，而是渲染整个 DOM，说白了就是无脑刷新，这样就导致性能不好，所以后面只能不断通过其他办法来避免不必要的刷新，或者优化无脑刷新的性能

当然 vue 精准刷新也是需要付出代价的，需要给每个组件配置监视器，管理依赖收集和派发更新，有一些性能消耗。

### 编译优化

Vue 能够做到数据劫持，再到 Vue3 动静结合的 Diff 思想也得益于它的模板语法实现了静态编译。就是能做到预编译优化，可以静态分析，在解析模板时能根据解析到的不同的标签、文本等分别执行对应的回调函数来构造 AST，而 React 虽然 JSX 语法更加灵活，可也正是因为这样导致可以优化的地方不足，重新渲染时就是一堆递归调用 React.createElement，无法从模板层面进行静态分析，也就做不到双向绑定，即使是很厉害的 fiber，也是因为伤害已经造成，所以通过时间分片的优化来弥补伤害吧，因为已经无法在编译阶段进行优化了，这也是这个设计所带来的问题吧

### 从加载速度和运行时性能

Vue 在更新时性能优化方面需要的**心智负担**可能会少那么一点，特别是 Vue3，而 React 如果不注意，容易导致一些组件无用的 Diff

### 总结

对于中小系统的开发，建议用 vue,因为不管是上手还是开发难度上都很简单，开发效率也高，而且它有更小的打包体积，毕竟在移动端网络差异大的情况下，资源体积是非常重要的。但像是一些中后台系统，或者一些大点的项目，会越做越大的，多人协作开发的，就用 React，因为它的函数式编程有更加灵活的结构和可扩展性，丰富的生态圈和工具链，解决方案多，后期也更方便迭代与维护，还适用原生 APP，所以我会偏向 React。

## react 中用到的 diff 算法

## react 中的虚拟 dom 原理

diff 算法的基础是**Virtual DOM**，Virtual DOM 是一棵以 JavaScript 对象作为基础的树，在 React 中通常是通过 JSX 编译而成的，每一个节点称为 VNode，用对象属性来描述节点，实际上它是一层对真实 DOM 的抽象，最终可以通过渲染操作使这棵树映射到真实环境上，简单来说 Virtual DOM 就是一个**Js 对象，用以描述整个文档**。

#### React 中 diff 算法的理解

diff 算法用来计算出 Virtual DOM 中改变的部分，然后针对该部分进行 DOM 操作，而不用重新渲染整个页面，渲染整个 DOM 结构的过程中开销是很大的，需要浏览器对 DOM 结构进行重绘与回流，而 diff 算法能够使得操作过程中只更新修改的那部分 DOM 结构而不更新整个 DOM，这样能够最小化操作 DOM 结构，能够最大程度上减少浏览器重绘与回流的规模。

### diff 算法

React 在内存中维护一颗虚拟 DOM 树，当数据发生改变时(state & props)，会自动的更新虚拟 DOM，获得一个新的虚拟 DOM 树，然后通过 Diff 算法，比较新旧虚拟 DOM 树，找出最小的有变化的部分，将这个变化的部分 Patch 加入队列，最终批量的更新这些 Patch 到实际的 DOM 中

## react 中的 fiber 架构以及是如何达到异步可中断更新的

## node 如何做负载均衡？

> 这个题我只说到了 process.fork 没有说到 cluster 点子上
