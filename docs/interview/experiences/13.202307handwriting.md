---
title: 202307手写汇总
order: 13
group:
  order: 0
  title: interview
nav:
  order: 3
  title: 'interview'
  path: /interview
---

> 0801 40 道手写题 先拿 40 道题目练练手,八月目标是 100 道

> 0805 50 道题

```js
/**
 * 1.myCall/myApply
 * 2.mockNew
 * 3.LRU 最近最少更新 缓存淘汰策略
 * 4.compose 组合，koa洋葱模型
 * 5.myBind
 * 6.curry(参数固定和不固定)
 * 7.bigIntSum 大数相加
 * 8.deepClone 深浅拷贝
 * 9.16进制转 rgb or rgb 转 16 进制
 * 10.mockMap/mockFilter 数组方法重写
 * 11.myReduce 重写
 * 12.flatter 扁平化手写
 * 13.手写发布订阅模式
 * 14.instanceof 手写
 * 15.手写选择排序和插入排序
 * 16.手写二分法
 * 17.手写驼峰转换
 * 18.手写防抖和节流
 * 19.反转链表
 * 20.手写Promise
 * 21.手写vue版render
 * 22.手写数字的千分位分割法
 * 23.实现一个 node 异步函数的 promisify
 * 24.封装一个类使对象可以被 for of 遍历
 * 25.删除链表一个节点
 * 26.手写async/await
 * 27.手写pipe/redux中的compose
 * 28.Promise.all/any/race/allSettled
 * 29.手写并发控制器!!!
 * 30.手写ajax
 * 31.手写jsonp
 * 32.[如何最快捷计算【白屏时间 FCP】和【首屏时间 LCP】](https://mp.weixin.qq.com/s/66_ssrmZpzeddm3FugiMFQ)
 * 33.URL参数解析
 * 34.手写去重
 * 35.useEvent
 * 36.useFetch 如何同时保持函数引用不变与访问到最新状态。
 * 37.链表是否有环？
 * 38.缓存memo函数
 * 39.手写函数重载
 * 40.二叉树前中后序遍历(迭代方式)
 * 41.冒泡排序和归并排序
 * 42.滑动窗口，无重复字符的最长子串
 * 43.实现一个带缓存斐波那契数列
 * 44.最大子序和
 * 45.实现简单的hash路由跟history路由
 * 46.二叉树的层序遍历
 * 47.二叉树前中后序遍历(递归方式)
 * 48.如何实现无限累加的一个函数
 * 49.手写NOSSR
 * 50.数组随机展示以及随机取一个数字展示
 **/
```

## 1.myCall/myApply

```js
Function.prototype.myCall = function (context, ...rest) {
  var obj = new Object(context) || window;
  var sys = Symbol('');
  obj[sys] = this;
  var res = obj[sys](...rest);
  delete obj[sys];
  return res;
};
```

## 2.mockNew

```js
function mockNew(fn, ...rest) {
  var target = Object.create(fn.prototype);
  var res = fn.apply(target, rest);
  return res instanceof Object ? res : target;
}
function TT(name) {
  this.name = name;
}
var tt1 = new TT('cpp');
console.log(tt1);
var tt2 = mockNew(TT, 'cpp2');
console.log(tt2);
```

## 3.LRU 最近最少更新 缓存淘汰策略

```js
class LRU {
  constructor(limit) {
    this.cache = new Map();
    this.limit = limit;
  }
  get(key) {
    var val = this.cache.get(key);
    if (val || this.cache.has(key)) {
      this.cache.delete(key);
      this.cache.set(key, val);
    } else {
      return -1;
    }
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.limit <= this.cache.size) {
      var oldKey = this.cache.keys.value().next;
      this.cache.delete(oldKey);
    }
    this.cache.set(key, value);
  }
}
```

## 4.compose 组合，koa 洋葱模型

```js
function compose(middlewares) {
  return function (ctx, next) {
    return dispatch(i);
    function dispatch(i) {
      var fn = middlewares[i];
      if (i === middlewares.length) fn = next;
      // 当 fn 为空的时候，就会开始执行 next() 后面部分的代码
      if (!fn) return Promise.resolve();
      try {
        // 执行中间件，留意这两个参数，都是中间件的传参，第一个是上下文，第二个是 next 函数
        // 也就是说执行 next 的时候也就是调用 dispatch 函数的时候
        return Promise.resolve(fn(ctx, () => dispatch(i + 1)));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
}
```

## 5.myBind

bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )

```js
Function.prototype.myBind = function (context, ...rest) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fbind =  function () {
    var bindArgs = Array.prototype.slice.call(arguments);
    // self.apply(context, args.concat(bindArgs));
     // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
    // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
    self.apply(this instanceOf self ? this : context, args.concat(bindArgs))
  };
  fbind.prototype = this.prototype
  return fbind
};
// second
Function.prototype.myBind = function (context) {
  var self = this
  var args = Array.prototype.slice.call(arguments, 1)
  var fBridge = function () {}
  var fBind = function() {
    var bindArgs = Array.prototype.slice.call(arguments)
    self.apply(this instanceof self ? this : context, rgs.concat(bindArgs)
  }
  fBridge.prototype = this.prototype
  fBind.prototype = new fBridge()
  return fBind
}
```

## 6.两种 curry 柯里化函数

将一个多参数的函数转化为**多个嵌套**的单参数函数

```js
// 参数不固定
function curryFn(fn) {
  var arr = [];
  return function temp(...rest) {
    if (rest.length) {
      arr.push(...rest);
      return temp;
    } else {
      var val = fn.apply(this, arr);
      arr = [];
      return val;
    }
  };
}
var sum = (...rest) => rest.reduce((pre, cur) => cur + pre, 0);
var getCurry = curryFn(sum);
getCurry(1)(2)(3)();
// 参数固定
function curryFn1(fn) {
  function temp(...rest) {
    if (rest.length === fn.length) {
      return fn.apply(this, rest);
    } else {
      return (...arg) => temp(...rest.concat(arg));
    }
  }
  return temp;
}

var sum1 = (a, b, c) => a + b + c;
var getCurry2 = curryFn1(sum1);
getCurry2(22)(11)(33);
```

## 7.bigIntSum 大数相加

```js
function bigIntSum(a, b) {
  var len = Math.max(a.length, b.length);
  a = a.padStart(len, 0);
  b = b.padStart(len, 0);
  var res = '';
  var flag = 0;
  for (let i = len - 1; i >= 0; i--) {
    flag = Number(a[i]) + Number(b[i]) + flag;
    res = (flag % 10) + res;
    flag = Math.floor(flag / 10);
  }
  return flag === '1' ? '1' + res : res;
}
bigIntSum('123', '123');
```

## 8.deepClone 深浅拷贝

```js
function deepClone(obj) {
  if (obj typeof !== 'Object') {
    return obj
  }
  var target = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    if(obj.hasOwnProperty(key)) {
      let item = obj[key]
      target[key] = item instanceof Object ? deepClone(item) : item
    }
  }
  return target
}
```

## 9.16 进制转 rgb or rgb 转 16 进制

```js
// rgb(255,255,255) => #ffffff
function rgbToHex(str) {
  var rgbs = str.split(/[^\d]+/);
  console.log(rgbs, 'rrr');
  var [, r, g, b] = rgbs;
  const toHex = (hex) => {
    var t = (+hex).toString(16);
    return t.length === 1 ? `0${t}` : t;
  };
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
rgbToHex('rgb(255,255,255)');

// #fffff => rgb(255,255,255)
function hexToRgb(str) {
  var rgb = str.replace('#', '0x');
  var r = rgb >> 16;
  var g = (rgb >> 8) & 0xff;
  var b = rgb & 0xff;
  return `rgb(${r},${g},${b})`;
}
hexToRgb('#ffffff');
```

## 10.mockMap/mockFilter 数组方法重写

```js
Array.prototype.mockMap = function (fn, context = window) {
  var arr = this;
  var res = [];
  for (let i = 0; i < arr.length; i++) {
    res.push(fn.call(context, arr[i], i, arr));
  }
  return res;
};

var sum = [1, 2, 3].map((e) => e * 2);
var sum2 = [11, 22, 33].mockMap((e) => e * 2);
console.log(sum, sum2);

Array.prototype.mockFilter = function (fn, context = window) {
  var arr = this;
  var res = [];
  for (let i = 0; i < arr.length; i++) {
    if (fn.call(context, arr[i], i, arr)) {
      res.push(arr[i]);
    }
  }
  return res;
};
var filter = [1, 2, 3].filter((e) => e > 1);
var filter2 = [1, 2, 3].mockFilter((e) => e > 1);
console.log(filter, filter2);
```

## 11.myReduce 重写!!

```js
var sum = [1, 2, 3].reduce((pre, cur) => cur + pre, 10);
console.log(sum);

Array.prototype.mockReduce = function (fn, init) {
  var arr = this;
  var res = init ? init : arr[0];
  for (let i = init ? 0 : 1; i < arr.length; i++) {
    res = fn.call(null, res, arr[i], i, arr);
  }
  return res;
};
var sum2 = [1, 2, 3].mockReduce((pre, cur) => pre + cur, 10);
console.log(sum2);
```

## 12.flatten

```js
function myFlatten(arr) {
  var stack = [...arr];
  var res = [];
  while (stack.length) {
    var cur = stack.pop();
    if (Array.isArray(cur)) {
      stack.push(...cur);
    } else {
      res.push(cur);
    }
  }
  return res.reverse();
}
function myFlatten1(arr) {
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? myFlatten(cur) : cur);
  }, []);
}

function myFlatten2(arr) {
  return arr.reduce((pre, cur) => {
    if (Array.isArray(cur)) {
      const other = myFlatten2(cur);
      return [...pre, ...other];
    }
    return [...pre, cur];
  }, []);
}
flatten([1, 2, [3, 4, [5, 9]]]);
```

## 13.手写发布订阅模式

```js
class Event {
  constructor() {
    this.events = {}
  }
  on(type, fn) {
    if (this.events[type]) {
      this.events[type].push(fn)
    } else {
      this.events[type] = [fn]
    }
  }
  emit(type. ...rest) {
    if (this.events[type]) {
      this.events[type].forEach((fn) => fn.apply(this, rest))
    }
  }
  off(type, fn) {
    if (this.events[type] && !fn) {
      this.events[type] = []
    } else (fn) {
      this.events[type].filter((x) => x !== fn)
    }
  }
  once(type, cb) {
    const fn = () => {
      cb()
      this.off(type, fn)
    }
    this.on(type, fn)
  }
}
```

## 14.instanceof 手写

```js
// 用于检测构造函数的原型是否在某一个实例的原型链上
function mockInstanceof(l, r) {
  l = Object.getPrototypeOf(l); // l.__propto__
  while (l) {
    if (l === r.prototype) {
      return true;
    }
    l = Object.getPrototypeOf(l); // l.__propto__
  }
  return false;
}
function mockInstanceof(l, r) {
  return r.prototype.isPrototypeOf(l);
}
```

## 15.手写选择排序和插入排序

```js
function selectSort(arr) {
  var min = 0;
  for (let i = 0; i < arr.length; i++) {
    min = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    }
    var temp = arr[i];
    arr[i] = arr[min];
    arr[min] = temp;
  }
  return arr;
}
selectSort([11, 222, 11, 2, 3, 0, 8, 6]);

// 插入排序
function inserSort(arr) {
  var pre, cur;
  for (let i = 1; i < arr.length; i++) {
    pre = i - 1;
    cur = arr[i];
    while (pre >= 0 && arr[pre] > cur) {
      arr[pre] = arr[pre - 1];
      pre--;
    }
    arr[pre + 1] = cur;
  }
  return arr;
}
inserSort([11, 222, 11, 2, 3, 0, 8, 6]);
```

## [16.手写二分法查找](https://leetcode.cn/problems/binary-search/description/)

```js
// 输入: nums = [-1,0,3,5,9,12], target = 9
// 输出: 4
// 解释: 9 出现在 nums 中并且下标为 4
function binary(arr, target) {
  var start = 0;
  var end = arr.length - 1;
  while (start <= end) {
    var mid = start + Math.floor((end - start) / 2);
    if (arr[mid] > target) {
      end = mid - 1;
    } else if (arr[mid] < target) {
      start = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}
binary([-1, 0, 3, 5, 9, 12], 9);
```

> 二分查找通过不断将搜索范围减半，迅速找到目标值或确认其不存在。这使得它成为在有序数组中寻找值的最快方式之一。请注意，前提是数组必须有序，否则二分查找将不适用。

## 17.手写驼峰转换

```js
function chartUppercase(str) {
  return str.replace(/[-|@](^\w)/g, (m, p) => {
    return p.toUpperCase();
  });
}
chartUppercase('cpp-wmh'); // cppWmh
```

## 18.手写防抖和节流

防抖：防止抖动，单位时间内事件触发会被重置，避免事件被触发多次。代码实现重在清零 clearTimeout。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。

节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。代码实现重在一定的时间段内执行一次。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。

```js
// 一段时间内多次触发只会执行一次 控制执行次数 应用场景： 防抖提交
function debounce(fn, delay) {
  var timer = null;
  return (...rest) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, rest);
      timer = null;
    }, delay);
  };
}
// 节流 执行频率变低 应用场景：拖拽画布或者拖拽窗口
function throttle(fn, delay) {
  var cur = 0;
  return (...rest) => {
    var exeTime = new Date().getTime();
    if (exeTime - cur > delay) {
      fn.apply(this, rest);
      cur = exeTime;
    }
  };
}
function throttle2(fn, delay) {
  let timer = null;
  return (...rest) => {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, rest);
        timer = null;
      }, delay);
    }
  };
}
```

## 19.反转链表

```js
var node = {
  val: 1,
  next: {
    val: 2,
    next: {
      val: 3,
      next: {
        val: 4,
        next: null,
      },
    },
  },
};
function revserLink(node) {
  var cur = node;
  var pre = null;
  while (cur) {
    var next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}
revserLink(node);
```

## 20.手写 Promise

```js
class MockPromise {
  constructor(exeFn) {
    this.data = undefined;
    this.cbs = [];
    const resolve = function (val) {
      setTimeout(() => {
        this.data = val;
        this.cbs.forEach((cb) => cb());
      });
    };
    exeFn(resolve);
  }
  then(onFulfilled, onReject) {
    return new MockPromise((resolve) => {
      this.cbs.push(() => {
        var val = onFullfilled(this.data);
        if (val instanceof MockPromise) {
          val.then(resolve);
        } else {
          resolve(val);
        }
      });
    });
  }
}
```

## 21.手写 vue 版 render

```js
function render(str, data) {
  var reg = /\{\{(\w+)\}\}/;
  if (reg.test(str)) {
    var key = reg.exec(str)[1];
    str = str.replace(reg, data[key]);
    return render(str, data);
  }
  return str;
}
render('name:{{name}},age:{{age}}', { name: 'cpp', age: 30 });
```

## 22.千分位分割

```js
function thousand(str) {
  return str.replace(/(?!^)(?=(\d{3})+$)/g, ',');
}
thousand('123456789');
//有小数点
let num2 = '342243242322.3432423';
num2.replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
```

## 23.实现一个 node 异步函数的 promisify

```js
// 输入：
// 原有的callback调用
fs.readFile('test.js', function (err, data) {
  if (!err) {
    console.log(data);
  } else {
    console.log(err);
  }
});
// 输出：
// promisify后
var readFileAsync = promisify(fs.readFile);
readFileAsync('test.js').then(
  (data) => {
    console.log(data);
  },
  (err) => {
    console.log(err);
  },
);
// node端的错误回调变成promise形式
function Promisify(fn) {
  return (...rest) => {
    return new Promise((resolve, reject) => {
      // rest.push((err, ...val) => {
      //   if (val) {
      //     resolve(val);
      //   } else {
      //     reject(err);
      //   }
      // });
      // fn.apply(this, rest);
      // rest[0] 约等于 test.js
      fn(rest[0], (err, ...val) {
        if (err) {
          reject(err)
        } else {
          resolve(val)
        }
      })
    });
  };
}
```

## 24.封装一个类使对象可以被 for of 遍历

```js
class MockIterator {
  constructor(obj) {
    this.obj = obj;
    this.len = Object.keys(obj).length;
    this.i = 0;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (this.i < this.len) {
      return {
        done: false,
        value: this.obj[this.i++],
      };
    } else {
      return {
        done: true,
        value: undefined,
      };
    }
  }
}
var test = {
  0: 'cpp',
  1: '33',
  length: 2,
};
for (let item of new MockIterator(test)) {
  console.log(item);
}
```

## 25.删除链表的一个节点

a. [只是删除其中的一个子节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/submissions/210061020/)

```js
function deletenode(node) {
  node.val = node.next.val;
  node.next = node.next.next;
}
```

b.[2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)

c.[剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```js
/**
 * 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。
 * 示例： 输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 * 节点next指针直接指向下下一个节点
 */
var deleteNode = function (head, val) {
  var dummy = {
    val: null,
    next: head,
  };
  var cur = dummy;
  while (cur.next) {
    if (cur.next.val === val) {
      cur.next = cur.next.next;
      continue;
    }
    cur = cur.next;
  }
  return dummy.next;
};
```

## 26.手写 async/await

```js
function mockAsync(fn) {
  return (...rest) => {
    var asyncFn = fn(...rest);
    return new Promise((resolve, reject) => {
      step('next');
      function step(key, ...name) {
        var genRes;
        try {
          genRes = asyncFn[key](...name);
        } catch (e) {
          reject(e);
        }
        const {value, done} = genRes
        if (done) {
            return resolve(value);
          } else {
            return Promise.resolve(value).then(
                (res) => {
                  return step('next', res);
                },
                (err) => {
                  return step('throw', err);
                },
              ),
          }
      }
    });
  };
}
var getData = () => new Promise((resolve) => setTimeout(() => resolve('data'), 1000));
var test = mockAsync(function* testG() {
  const data = yield getData();
  console.log('data1: ', data);
  const data2 = yield getData();
  console.log('data2: ', data2);
  return 'success';
});
test().then((res) => console.log(res, 'cpp'));
```

## 27.手写 pipe/redux 中的 compose

```js
function ten(x) {
  console.log('11');
  return x;
}
function twoTen(x) {
  console.log('22');
  return x * 2;
}
function threeTen(x) {
  console.log('33');
  return x * 3;
}
// 从左到右执行
function pipe(...rest) {
  if (!rest) return (x) => x;
  if (rest.length === 1) return rest[0];
  return (arg) => {
    return rest.reduce((pre, cur) => cur(pre), arg);
  };
}
var pipeFn = pipe(ten, twoTen, threeTen);
// 从右到左执行
function compose(...rest) {
  if (!rest) return (x) => x;
  if (rest.length === 1) return rest[0];
  return rest.reduce(
    (pre, cur) =>
      (...arg) =>
        pre(cur(...arg)),
  );
}
var fn = compose(ten, twoTen, threeTen);
fn(10);
```

## 28.Promise.all/any/race/allSettled

```js
class MyPromise {
  static all(arr) {
    return new Promise((resolve, reject) => {
      var res = [];
      for (let [index, item] of arr.entries()) {
        Promise.resolve(item).then(
          (val) => {
            if (index === arr.length - 1) {
              resolve(res);
            }
            res[index] = val;
          },
          (err) => {
            reject(err);
          },
        );
      }
    });
  }
  static race(all) {
    return new Promise((resolve, reject) => {
      var res = [];
      for (let [index, item] of arr.entries()) {
        Promise.resolve(item).then(
          (val) => {
            resolve(val);
          },
          (err) => reject(err),
        );
      }
    });
  }
  static allSettled(all) {
    return new Promise((resolve, reject) => {});
  }
}
```

## 29.请求并发控制

```js
async function pool(array, limit, iteratorFn) {
  var res = []; // 存放结果
  var arr = []; // 存储当前正在执行的异步任务
  for (let i = 0; i < array.length; i++) {
    // 调用iteratorFn函数创建异步任务
    var p1 = Promise.resolve().then(() => iteratorFn(array[i], array));
    // 保存新的异步任务
    res.push(p1);
    // Limit值小于或等于总任务个数时，进行并发控制
    if (array.length >= limit) {
      // 当任务完成后，从正在执行的任务数组中移除已完成的任务
      var p2 = p1.then(() => arr.splice(arr.indexOf(p2), 1));
      // 保存正在执行的异步任务
      arr.push(p2);
      if (arr.length >= arr) {
        // 等待较快的任务执行
        await Promise.race(arr);
      }
    }
  }
  return Promise.all(res);
}
```

## 30.手写 ajax

```js
function mockAjax(url, cb) {
  return new Promise((resolve, reject) => {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === xhr.DONE && xhr.status === 200) {
        cb(resolve(xhr.responseText));
      }
    };
    xhr.send();
  });
}
```

## 31.手写 jsonp

```js
// 如何调用？
function mockJsonp(url, cb) {
  var funName = '?cb=' + Math.random().toString().slice(2);
  var script = document.createElement('script');
  script.src = url + funName;
  script.async = true;
  document.body.appendChild(script);
  window[funName] = function (data) {
    cb(data);
    delete window[funName];
    document.body.removeChild(script);
  };
}
mockJsonp('http://xx', (res) => {
  console.log(res);
});
```

## 33.URL 参数解析

```js
function parseUrlParams(url = location.search) {
  var queryQarams = new URLSearchParams(url);
  var obj = {};
  for (let key of queryQarams.keys()) {
    obj[key] = queryQarams.get(key);
  }
  return obj;
}
parseUrlParams('?name=cpp&age=31&hobby=writing');
// {name: 'cpp', age: '31', hobby: 'writing'}
```

## 34.手写去重

```js
function removeDup(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}
removeDup([1, 33, 44, 99, 11]);
```

## 35.useEvent

封装事件处理函数,在组件多次 render 时保持引用一致,函数内始终能获取到最新的 props 与 state

```js
import { useCallback, useRef, useLayoutEffect } from 'react';
function useEvent(fn) {
  const handleRef = useRef();
  useLayoutEffect(() => {
    handleRef.current = fn;
  });
  return useCallback((...arg) => {
    handleRef && handleRef.current(...arg);
  });
}
```

## 38.缓存函数

```js
var memorize = function (fn) {
  const cache = {};
  return function (...args) {
    const _args = JSON.stringify(args);
    return cache[_args] || (cache[_args] = fn.apply(this, args));
  };
};
var add = function (a, b) {
  console.log('函数缓存');
  return a + b;
};
var addFn = memorize(add);
var a1 = addFn(2, 6);
var a2 = addFn(2, 6);
var a3 = addFn(2, 6);
console.log(a1, a2, a3);
// 函数缓存
//8 8 8
```

## 39.手写函数重载

```js
function reloadFn(obj, name, fn) {
  var oldFn = obj[name];
  return (...rest) => {
    if (rest.length === fn.length) {
      fn.apply(this, rest);
    } else {
      oldFn.apply(this, rest);
    }
  };
}
```

## 40.二叉树前中后序遍历(迭代方式)

```js
// 前序 根左右
function preOrder(node, res = []) {
  if (!node) return res;
  var stack = [node];
  while (stack.length) {
    var cur = stack.pop();
    res.push(cur.val);
    cur.right && stack.push(cur.right);
    cur.left && stack.push(cur.left);
  }
  return res;
}
// 中序 左根右
function inOrder(node, res = []) {
  if (!node) return res;
  var stack = [];
  var root = node;
  while (root || stack.length) {
    if (root) {
      stack.push(root.left);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(cur.val);
      root = root.right;
    }
  }
  return res;
}
// 后序 左右根
function postOrder(node) {
  if (!node) return res;
  var stack = [node];
  while (stack.length) {
    var cur = stack.pop();
    res.push(cur.val);
    cur.left && stack.push(cur.left);
    cur.right && stack.push(cur.right);
  }
  return res.reverse();
}
```

## 41.冒泡排序和归并排序

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
bubbleSort([11, 3, 44, 1, 99, 7]);
// 归并排序
```

## 42.滑动窗口，无重复字符的最长子串

```js
// 题目记不清了
```

## 43.实现一个带缓存斐波那契数列

```js
function fibonce(n) {
  if (n <= 1) return 1;
  if (n === 2) return n;
  return fibonce(n - 1) + fibonce(n - 2);
}
fibonce(3);
```

## 44.最大子序和

```js
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
function maxSumChild(arr) {
  var max = 0
  var sum = 0
  for (let item of arr) {
    if (sum > 0) {
      sum = sum + item
    } else {
      sum = item
    }
    max = Math.max(max, sum)
  }
  return max
}
maxSumChild([-2,1,-3,4,-1,2,1,-5,4])
```

## 45.实现简单的 hash 路由跟 history 路由!!!

> 这个是最难的！！！

```js

```

## 46.二叉树的层序遍历

```js
var node = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: {
      val: 3,
      left: null,
      right: null,
    },
  },
  right: {
    val: 4,
    left: null,
    right: {
      val: 5,
      left: {
        val: 6,
        left: null,
        right: null,
      },
      right: {
        val: 7,
        left: null,
        right: null,
      },
    },
  },
};

// 层序遍历
function levelOrder(node) {
  if (!node) return [];
  var queue = [node];
  var res = [];
  while (queue.length) {
    var arr = [];
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      var last = queue.shift();
      last && arr.push(last.val);
      if (last.left) {
        queue.push(last.left);
      }
      if (last.right) {
        queue.push(last.right);
      }
    }
    res.push(arr);
  }
  return res;
}
levelOrder(node);
```

## 47.二叉树前中后序遍历(递归方式)

```js
// 前序 根左右
function preOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      res.push(node.val);
      dfs(node.left);
      dfs(node.right);
    }
  };
  dfs(node);
  return res;
}
// 中序 左根右
function inOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      dfs(node.left);
      res.push(node.val);
      dfs(node.right);
    }
  };
  dfs(node);
  return res;
}
// 后序 左右根
function postOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      dfs(node.left);
      dfs(node.right);
      res.push(node.val);
    }
  };
  dfs(node);
  return res;
}
```

## [48.如何实现无限累加的一个函数?](https://mp.weixin.qq.com/s/Bh5pGQoZBjdc-h5ukbp7HQ)

> 题目给个示例最好

```js
sum(1, 2, 3).valueOf(); //6
sum(2, 3)(2).valueOf(); //7
sum(1)(2)(3)(4).valueOf(); //10
sum(2)(4, 1)(2).valueOf(); //9
sum(1)(2)(3)(4)(5)(6).valueOf(); // 21
function sum(...rest) {
  // var res;
  // var add = (...arg) => {
  //   if (arg.length === rest.length) {
  //     res = rest.reduce((a, b) => a + b);
  //   }
  //   return (...arg1) => add(...[...arg1, ...arg]);
  // };
  // return {
  //   valueOf: add(),
  // };
  var add = (...arg) => sum(...arg, ...rest);
  add.valueOf = () => rest.reduce((a, b) => a + b);
  return add;
}
sum(1, 2, 3).valueOf();
```

## 49.NoSSR

```js
import { useEffect, useState } from 'react';

const NoSSR = (props) => {
  const { children } = props;
  const [init, setInit] = useState(false);
  useEffect(() => {
    setInit(true);
  }, []);
  if (init) {
    return <>{children}</>;
  } else {
    return null;
  }
};
```

## 50.数组随机展示以及随机取一个数字展示

```js
// 随机展示一个数字
var arr = [1, 2, 3, 4, 5, 6];
function randomDisplay(arr) {
  return arr[Math.floor(arr.length * Math.random())];
}
randomDisplay(arr);

// 打乱数组
function sanLuanArr(arr) {
  return arr.sort(() => 0.5 - Math.random());
}
sanLuanArr(arr);
```
