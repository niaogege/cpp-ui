---
title: 202307手写汇总
order: 13
group:
  order: 0
  title: interview
nav:
  order: 3
  title: 'interview'
  path: /interview
---

> 0801 40 道手写题 先拿 40 道题目练练手,八月目标是 100 道

> 0805 50 道题

```js
/**
 * 1.myCall/myApply
 * 2.mockNew
 * 3.LRU 最近最少更新 缓存淘汰策略
 * 4.compose 组合，koa洋葱模型
 * 5.myBind
 * 6.curry(参数固定和不固定)
 * 7.bigIntSum 大数相加
 * 8.deepClone 深浅拷贝
 * 9.16进制转 rgb or rgb 转 16 进制
 * 10.mockMap/mockFilter 数组方法重写
 * 11.myReduce 重写
 * 12.flatter 扁平化手写
 * 13.手写发布订阅模式
 * 14.instanceof 手写
 * 15.手写选择排序和插入排序
 * 16.手写二分法
 * 17.手写驼峰转换
 * 18.手写防抖和节流
 * 19.反转链表
 * 20.手写Promise
 * 21.手写vue版render
 * 22.手写数字的千分位分割法
 * 23.实现promisify
 * 24.封装一个类使对象可以被 for of 遍历
 * 25.删除链表一个节点
 * 26.手写async/await
 * 27.手写pipe/redux中的compose
 * 28.Promise.all/any/race/allSettled
 * 29.手写并发控制器!!!
 * 30.手写ajax
 * 31.手写jsonp
 * 33.URL参数解析
 * 34.手写去重
 * 35.useEvent
 * 36.useFetch 如何同时保持函数引用不变与访问到最新状态。
 * 37.链表是否有环？
 * 38.缓存memo函数
 * 39.手写函数重载
 * 40.二叉树前中后序遍历(迭代方式)
 * 41.冒泡排序和归并排序
 * 42.滑动窗口，无重复字符的最长子串
 * 43.实现一个带缓存斐波那契数列
 * 44.最大子序和
 * 45.实现简单的hash路由跟history路由
 * 46.二叉树的层序遍历
 * 47.二叉树前中后序遍历(递归方式)
 * 48.如何实现无限累加的一个函数
 * 49.手写NOSSR
 * 50.数组随机展示以及随机取一个数字展示
 **/
```

## 1.myCall/myApply

```js
Function.prototype.myCall = function (context, ...rest) {
  var obj = new Object(context) || window;
  var sys = Symbol('');
  obj[sys] = this;
  var res = obj[sys](...rest);
  delete obj[sys];
  return res;
};
```

## 5.myBind

bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )

```js
Function.prototype.myBind = function (context, ...rest) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fbind =  function () {
    var bindArgs = Array.prototype.slice.call(arguments);
    // self.apply(context, args.concat(bindArgs));
     // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
    // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
    self.apply(this instanceOf self ? this : context, args.concat(bindArgs))
  };
  fbind.prototype = this.prototype
  return fbind
};
// second
Function.prototype.myBind = function (context) {
  var self = this
  var args = Array.prototype.slice.call(arguments, 1)
  var fBridge = function () {}
  var fBind = function() {
    var bindArgs = Array.prototype.slice.call(arguments)
    self.apply(this instanceof self ? this : context, rgs.concat(bindArgs)
  }
  fBridge.prototype = this.prototype
  fBind.prototype = new fBridge()
  return fBind
}
```

## 6.两种 curry 柯里化函数

将一个多参数的函数转化为**多个嵌套**的单参数函数

```js
// 参数不固定
function curryFn(fn) {
  var arr = [];
  return function temp(...rest) {
    if (rest.length) {
      arr.push(...rest);
      return temp;
    } else {
      var val = fn.apply(this, arr);
      arr = [];
      return val;
    }
  };
}
var sum = (...rest) => rest.reduce((pre, cur) => cur + pre, 0);
var getCurry = curryFn(sum);
getCurry(1)(2)(3)();
// 参数固定
function curryFn1(fn) {
  function temp(...rest) {
    if (rest.length === fn.length) {
      return fn.apply(this, rest);
    } else {
      return (...arg) => temp(...rest.concat(arg));
    }
  }
  return temp;
}

var sum1 = (a, b, c) => a + b + c;
var getCurry2 = curryFn1(sum1);
getCurry2(22)(11)(33);
```

## 7.bigIntSum 大数相加

```js
function bigIntSum(a, b) {
  var len = Math.max(a.length, b.length);
  a = a.padStart(len, 0);
  b = b.padStart(len, 0);
  var res = '';
  var flag = 0;
  for (let i = len - 1; i >= 0; i--) {
    flag = Number(a[i]) + Number(b[i]) + flag;
    res = (flag % 10) + res;
    flag = Math.floor(flag / 10);
  }
  return flag === '1' ? '1' + res : res;
}
bigIntSum('123', '123');
```

## 9.16 进制转 rgb or rgb 转 16 进制

```js
// rgb(255,255,255) => #ffffff
function rgbToHex(str) {
  var rgbs = str.split(/[^\d]+/);
  console.log(rgbs, 'rrr');
  var [, r, g, b] = rgbs;
  const toHex = (hex) => {
    var t = (+hex).toString(16);
    return t.length === 1 ? `0${t}` : t;
  };
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
rgbToHex('rgb(255,255,255)');

// #fffff => rgb(255,255,255)
function hexToRgb(str) {
  var rgb = str.replace('#', '0x');
  var r = rgb >> 16;
  var g = (rgb >> 8) & 0xff;
  var b = rgb & 0xff;
  return `rgb(${r},${g},${b})`;
}
hexToRgb('#ffffff');
```

## 12.flatten

```js
function myFlatten(arr) {
  var stack = [...arr];
  var res = [];
  while (stack.length) {
    var cur = stack.pop();
    if (Array.isArray(cur)) {
      stack.push(...cur);
    } else {
      res.push(cur);
    }
  }
  return res.reverse();
}
function myFlatten1(arr) {
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? myFlatten(cur) : cur);
  }, []);
}

function myFlatten2(arr) {
  return arr.reduce((pre, cur) => {
    if (Array.isArray(cur)) {
      const other = myFlatten2(cur);
      return [...pre, ...other];
    }
    return [...pre, cur];
  }, []);
}
flatten([1, 2, [3, 4, [5, 9]]]);
```

## 14.instanceof 手写

```js
// 用于检测构造函数的原型是否在某一个实例的原型链上
function mockInstanceof(l, r) {
  l = Object.getPrototypeOf(l); // l.__propto__
  while (l) {
    if (l === r.prototype) {
      return true;
    }
    l = Object.getPrototypeOf(l); // l.__propto__
  }
  return false;
}
function mockInstanceof(l, r) {
  return r.prototype.isPrototypeOf(l);
}
```

## 17.手写驼峰转换

```js
function chartUppercase(str) {
  return str.replace(/[-|@](^\w)/g, (m, p) => {
    return p.toUpperCase();
  });
}
chartUppercase('cpp-wmh'); // cppWmh
```

## 22.千分位分割

```js
functionn thousand() {}
//有小数点
let num2 = '342243242322.3432423'
num2.replace(/(\d)(?=(\d{3})+\.)/g,'$1,')
```

## 24.封装一个类使对象可以被 for of 遍历

```js
class MockIterator {
  constructor(obj) {
    this.obj = obj;
    this.len = Object.keys(obj).length;
    this.i = 0;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (this.i < this.len) {
      return {
        done: false,
        value: this.obj[this.i++],
      };
    } else {
      return {
        done: true,
        value: undefined,
      };
    }
  }
}
var test = {
  0: 'cpp',
  1: '33',
  length: 2,
};
for (let item of new MockIterator(test)) {
  console.log(item);
}
```

## 25.删除链表的一个节点

a. [只是删除其中的一个子节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/submissions/210061020/)

```js
function deletenode(node) {
  node.val = node.next.val;
  node.next = node.next.next;
}
```

b.[2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)

c.[剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```js
/**
 * 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。
 * 示例： 输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 * 节点next指针直接指向下下一个节点
 */
var deleteNode = function (head, val) {
  var dummy = {
    val: null,
    next: head,
  };
  var cur = dummy;
  while (cur.next) {
    if (cur.next.val === val) {
      cur.next = cur.next.next;
      continue;
    }
    cur = cur.next;
  }
  return dummy.next;
};
```

## 26.手写 async/await

```js
function mockAsync(fn) {
  return (...rest) => {
    var asyncFn = fn(...rest);
    return new Promise((resolve, reject) => {
      step('next');
      function step(key, ...name) {
        var genRes;
        try {
          genRes = asyncFn[key](...name);
        } catch (e) {
          reject(e);
        }
        const {value, done} = genRes
        if (done) {
            return resolve(value);
          } else {
            return Promise.resolve(value).then(
                (res) => {
                  return step('next', res);
                },
                (err) => {
                  return step('throw', err);
                },
              ),
          }
      }
    });
  };
}
var getData = () => new Promise((resolve) => setTimeout(() => resolve('data'), 1000));
var test = mockAsync(function* testG() {
  const data = yield getData();
  console.log('data1: ', data);
  const data2 = yield getData();
  console.log('data2: ', data2);
  return 'success';
});
test().then((res) => console.log(res, 'cpp'));
```

## 29.请求并发控制

```js
async function pool(array, limit, iteratorFn) {
  var res = []; // 存放结果
  var arr = []; // 存储当前正在执行的异步任务
  for (let i = 0; i < array.length; i++) {
    // 调用iteratorFn函数创建异步任务
    var p1 = Promise.resolve().then(() => iteratorFn(array[i], array));
    // 保存新的异步任务
    res.push(p1);
    // Limit值小于或等于总任务个数时，进行并发控制
    if (array.length >= limit) {
      // 当任务完成后，从正在执行的任务数组中移除已完成的任务
      var p2 = p1.then(() => arr.splice(arr.indexOf(p2), 1));
      // 保存正在执行的异步任务
      arr.push(p2);
      if (arr.length >= arr) {
        // 等待较快的任务执行
        await Promise.race(arr);
      }
    }
  }
  return Promise.all(res);
}
```

## 33.URL 参数解析

```js
function parseUrlParams(url = location.search) {
  var queryQarams = new URLSearchParams(url);
  var obj = {};
  for (let key of queryQarams.keys()) {
    obj[key] = queryQarams.get(key);
  }
  return obj;
}
parseUrlParams('?name=cpp&age=31&hobby=writing');
// {name: 'cpp', age: '31', hobby: 'writing'}
```

## 35.useEvent

封装事件处理函数,在组件多次 render 时保持引用一致,函数内始终能获取到最新的 props 与 state

```js
import { useCallback, useRef, useLayoutEffect } from 'react';
function useEvent(fn) {
  const handleRef = useRef();
  useLayoutEffect(() => {
    handleRef.current = fn;
  });
  return useCallback((...arg) => {
    handleRef && handleRef.current(...arg);
  });
}
```

## 38.缓存函数

```js
var memorize = function (fn) {
  const cache = {};
  return function (...args) {
    const _args = JSON.stringify(args);
    return cache[_args] || (cache[_args] = fn.apply(this, args));
  };
};
var add = function (a, b) {
  console.log('函数缓存');
  return a + b;
};
var addFn = memorize(add);
var a1 = addFn(2, 6);
var a2 = addFn(2, 6);
var a3 = addFn(2, 6);
console.log(a1, a2, a3);
// 函数缓存
//8 8 8
```

## 47.二叉树前中后序遍历(迭代方式)

```js
// 前序 根左右
function preOrder(node, res = []) {
  if (!node) return res;
  var stack = [node];
  while (stack.length) {
    var cur = stack.pop();
    res.push(cur.val);
    cur.right && stack.push(cur.right);
    cur.left && stack.push(cur.left);
  }
  return res;
}
// 中序 左根右
function inOrder(node, res = []) {
  if (!node) return res;
  var stack = [];
  var root = node;
  while (root || stack.length) {
    if (root) {
      stack.push(root.left);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(cur.val);
      root = root.right;
    }
  }
  return res;
}
// 后序 左右根
function postOrder(node) {
  if (!node) return res;
  var stack = [node];
  while (stack.length) {
    var cur = stack.pop();
    res.push(cur.val);
    cur.left && stack.push(cur.left);
    cur.right && stack.push(cur.right);
  }
  return res.reverse();
}
```

## 46.二叉树的层序遍历

```js
var node = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: {
      val: 3,
      left: null,
      right: null,
    },
  },
  right: {
    val: 4,
    left: null,
    right: {
      val: 5,
      left: {
        val: 6,
        left: null,
        right: null,
      },
      right: {
        val: 7,
        left: null,
        right: null,
      },
    },
  },
};

// 层序遍历
function levelOrder(node) {
  if (!node) return [];
  var queue = [node];
  var res = [];
  while (queue.length) {
    var arr = [];
    const len = queue.length;
    for (let i = 0; i < len; i++) {
      var last = queue.shift();
      last && arr.push(last.val);
      if (last.left) {
        queue.push(last.left);
      }
      if (last.right) {
        queue.push(last.right);
      }
    }
    res.push(arr);
  }
  return res;
}
levelOrder(node);
```

## 47.二叉树前中后序遍历(递归方式)

```js
// 前序 根左右
function preOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      res.push(node.val);
      dfs(node.left);
      dfs(node.right);
    }
  };
  dfs(node);
  return res;
}
// 中序 左根右
function inOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      dfs(node.left);
      res.push(node.val);
      dfs(node.right);
    }
  };
  dfs(node);
  return res;
}
// 后序 左右根
function postOrder(node) {
  var res = [];
  const dfs = (node) => {
    if (node) {
      dfs(node.left);
      dfs(node.right);
      res.push(node.val);
    }
  };
  dfs(node);
  return res;
}
```

## 49.NoSSR

```js
import { useEffect, useState } from 'react';

const NoSSR = (props) => {
  const { children } = props;
  const [init, setInit] = useState(false);
  useEffect(() => {
    setInit(true);
  }, []);
  if (init) {
    return <>{children}</>;
  } else {
    return null;
  }
};
```
