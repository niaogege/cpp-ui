---
title: 202308手写汇总(2)
order: 14
group:
  order: 0
  title: interview
nav:
  order: 3
  title: 'interview'
  path: /interview
---

> 0808 再接再厉 在背出 50 道题

> 0821 再接再厉 不忘初心 还有最后 20 道题

```js
/**
 * 1.[链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
 * 2.[盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
 * 3.[有效的括号](https://leetcode.cn/problems/valid-parentheses/)
 * 4.实现ES6的Class
 * 5.[实现ES6的Extend](https://mp.weixin.qq.com/s/8FmjffUnWx49LsyJn28XdA)
 * 6.使用reduce实现数组flat方法
 * 7.[寄生组合式继承](https://mp.weixin.qq.com/s/8-vWM7WMqZYMnw_pe7CXhg)
 * 8.
 * 9.once 函数 跟 memo函数差不多
 * 10.TS练习体操之Equal<A, B>
 * 11.滚动到底部懒加载数据Hooks实现
 * 12.TS练习之Pick<T, K>
 * 13.图片懒加载实现
 * 14.
 * 15.找出数组中出现次数最多的数字，如[1,2,1,2,3],打印出1和2，出现的次数是2；[1,2,5,5,5],打印5，出现的次数是3
 * 16.手写ts版Awaited<T>
 * 17.setInterval 实现 setTimeout / setTimeout 实现 setInterval
 * 18.手写虚拟DOM
 * 19.如何实现(a == 1 && a == 2 && a == 3)？
 * 20.实现数组中的findIndex/find/include
 * 21.[实现对象中的entries/fromEntries/assign](https://mp.weixin.qq.com/s/S-7w8KgG0R5mdFIcCT0Keg)
 * 22.二叉树的最小深度/最大深度(https://programmercarl.com/)
 * 23.TS手写IndexToUnion索引转联合类型/
 * 24.TS手写Unique 去重
 * 25.[手写axios以及核心组件拦截器](https://mp.weixin.qq.com/s/nmKU-Z1Ewc75HH0NxgvcCw)
 * 26.手写Object.create()的实现
 * 27.[写一个通用的事件侦听器函数](https://mp.weixin.qq.com/s/uKPVedfQkgEPYoRUtwyeQQ)
 * 28.怎么实现一个sleep
 * 29.对象数组去重
 * 30.查找字符串中出现最多的字符和个数
 * 31.实现一个 immutable
 * 32.惰性函数
 * 33.使用睡眠函数实现红绿灯代码，红灯2秒，黄灯1秒，绿灯3秒，循环改变颜色。
 * 34.[1s后输出1 2s后输出2 3s后输出3](https://juejin.cn/post/6920492226594373639?searchId=20230828231941247DD0C17D7CAD3D5286)
 * 35.TS手写联合转交叉
 * 36.TS实现内置函数Parameters和ReturnTypes
 * 37.基数排序
 * 38.堆排序
 * 39.桶排序
 * 40.如何实现上拉加载下拉刷新
 * 41.pipe/compose 管道函数
 * 42.洗牌算法
 * 43.单例模式
 * 44.观察者模式
 * 45.工厂模式
 * 46.
 */
```

### 4.实现 ES6 的 Class

### 5.[实现 ES6 的 Extend](https://mp.weixin.qq.com/s/8FmjffUnWx49LsyJn28XdA)

### 9.once 函数 跟 memo 函数差不多

```js
function memo(fn) {
  var cache = {}
  return (...rest) => {
    var args= JSON.stringify(rest)
    return cache[args] || cache[args] = fn.apply(this, rest)
  }
}
const once = (fn) => {
  let res, isFirst = true
  return function (...args) {
    if (!isFirst) return res
    res = fn.call(this, ...args)
    isFirst = false
    return res
  }
}
const f = (x) => x;
const onceF = once(f);
//=> 3
onceF(3);
//=> 3
onceF(4);
```

## 10.TS 练习体操之 Equal

```ts
type isEqual<A, B = A> = (<T>() => T extends A ? 1 : 2) extends <T>() => T extends B ? 1 : 2
  ? true
  : false;
type E11 = isEqual<1, 2>; // false
type E12 = isEqual<'string', string>; // false
type E13 = isEqual<string, string>; // true
```

## 12.TS 练习之 Pick

```ts
type PickMy<T, K extends keyof T> = {
  [P in K]?: T[P];
};
type PickMy1<T, K> = {
  [P in keyof T as P extends K ? P : T[P] extends {} ? P : never]: T[P];
};

type P1 = {
  name: string;
  age?: number;
};
type P2 = PickMy1<P1, 'name'>;
```

## 13.图片懒加载

```js
function lazyLoadImg(imgs) {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      const { target, intersectionRatio } = entry;
      if (intersectionRatio > 0) {
        target.src = target.dataset.src;
        observer.unobserve(target);
      }
    });
  });
  imgs.forEach((img) => {
    observer.observe(img);
  });
}
```

## 18.[手写虚拟 DOM](https://mp.weixin.qq.com/s/S-7w8KgG0R5mdFIcCT0Keg)

```js
function render(vnode, parent) {
  var mount = parent ? (el) => parent.appendChild(el) : (el) => el;
  if (typeof vnode === 'string') {
    return mount(document.createTextNode(vnode));
  } else {
    var dom = mount(document.createElement(vnode.type));
    // props
    Object.keys(vnode.props).forEach((key) => {
      var val = vnode.props[key];
      dom.setAttribute(key, val);
    });
    // child
    vnode.children.forEach((child) => {
      document.appendChild(render(child, parent));
    });
    return dom;
  }
}
render(Vnode, docuemnt.getElementById('app'));
```

## 21 手写 Object.assign

```js
var cpp = {
  name: 'cpp',
};
var obj = { age: 33 };
var target = Object.assign({ hobby: 'learn' }, cpp, obj);
console.log(target, 'target');

// 手写Object.assign()
function myAssign(target, ...source) {
  if (!target) {
    throw new TypeError('can not be null');
  }
  let res = Object(target);
  source.forEach((obj) => {
    if (obj) {
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          res[key] = obj[key];
        }
      }
    }
  });
  return res;
}
```

## 23 TS 手写 IndexToUnion 索引转联合类型

```ts
type NN1 = {
  age: number;
  name: string;
};
// expected
type NN2 =
  | {
      age: number;
    }
  | {
      name: string;
    };

type IndexToUnion<T> = {
  [P in keyof T]: {
    [K in P]: T[K];
  };
}[keyof T];

type NN3 = IndexToUnion<NN1>;
const tt3: NN3 = { age: '22' };
```

## 25 axios 以及拦截器

```js
// 添加请求拦截器
axios.interceptors.request.use(
  function (config) {
    // 在发送请求之前做些什么
    return config;
  },
  function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  },
);
```

移除拦截器

```js
const myInterceptor = axios.interceptors.request.use(function () {
  /*...*/
});
axios.interceptors.request.eject(myInterceptor);
```

## 20. 查找字符串中出现最多的字符和个数

## 26. Object.create()

```js
/**
 * ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型,阔以理解成对传入对象的浅复制缺点：引用类型的原型属性会被实例共享
 * @param target
 * @returns
 */
function MyObject(target) {
  function F() {}
  F.prototype = target;
  return new F();
}
```

## 29.对象数组去重

## 34.红灯 3 秒亮一次，黄灯 2 秒亮一次，绿灯 1 秒亮一次；如何让三个灯不断交替重复亮灯？

要求：用 Promise 实现

```js
function red() {
  console.log('red');
}
function green() {
  console.log('green');
}
function yellow() {
  console.log('yellow');
}

function sleep(fn, delay) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(fn());
    }, delay);
  });
}

function main() {
  return Promise.resolve()
    .then(() => {
      return sleep(red, 3000);
    })
    .then(() => {
      return sleep(yellow, 2000);
    })
    .then(() => {
      return sleep(green, 2000);
    })
    .then(() => main());
}
main();

// 第二种方式
async function main2() {
  while (true) {
    await sleep(red, 3000);
    await sleep(yellow, 2000);
    await sleep(green, 2000);
  }
}
```

## 35 联合转交叉类型

```ts
type Fork = { name: string } | { age: number };
type Fork2 = {
  name: string;
  age: number;
};

type UnionToFork<T> = (T extends T ? (x: T) => unknown : never) extends (x: infer R) => unknown
  ? R
  : never;
type Fork3 = UnionToFork<Fork>;
const fork3: Fork3 = { name: 'ccc', age: 222 };
```

## 40. 下拉刷新和上拉加载

```js
// 上拉加载 即滚动到底部进行加载
function scrollPage() {
  var scrollHeight = document.body.scrollHeight || document.documentElement.scrollHeight; // 文档内容的总高度
  var scrollBarTop = document.body.scrollTop || document.documentElement.scrollTop; // 滚动条的滚动距离
  const distance = 50; // 距离底部还有50的时候 加载下一页
  var clientHeight = window.innerHeight;
  if (scrollBarTop + clientHeight + distance >= scrollHeight) {
    console.log('toBottom');
  }
}
window.addEventListener('scroll', scrollPage);
window.removeEventListener('scroll', scrollPage);
```

### 下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作

```html
<main>
  <p class="refreshText"></p>
  <ul id="refreshContainer">
    <li>111</li>
    <li>222</li>
    <li>333</li>
    <li>444</li>
    <li>555</li>
    ...
  </ul>
</main>
```

```js
// 1.监听touchstart事件，记录初始的值
var _element = document.getElementById('refreshContainer'),
  _refreshText = document.querySelector('.refreshText'),
  _startPos = 0, // 初始的值
  _transitionHeight = 0; // 移动的距离

_element.addEventListener(
  'touchstart',
  function (e) {
    _startPos = e.touches[0].pageY; // 记录初始位置
    _element.style.position = 'relative';
    _element.style.transition = 'transform 0s';
  },
  false,
);
// 2.监听touchmove移动事件，记录滑动差值
_element.addEventListener(
  'touchmove',
  function (e) {
    // e.touches[0].pageY 当前位置
    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值

    if (_transitionHeight > 0 && _transitionHeight < 60) {
      _refreshText.innerText = '下拉刷新';
      _element.style.transform = 'translateY(' + _transitionHeight + 'px)';

      if (_transitionHeight > 55) {
        _refreshText.innerText = '释放更新';
      }
    }
  },
  false,
);
// 3.监听touchend离开的事件
_element.addEventListener(
  'touchend',
  function (e) {
    _element.style.transition = 'transform 0.5s ease 1s';
    _element.style.transform = 'translateY(0px)';
    _refreshText.innerText = '更新中...';
    // todo...
  },
  false,
);
```

## 41. 管道函数 pipe/compose

```js
// 从右到左
// redux源码
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args)),
  );
}

// 从左到右
function pipe(...rest) {
  let arr = Array.prototype.slice.call(arguments);
  return function (val) {
    return arr.reduce((pre, cur) => cur(pre), val);
  };
}
function fn2(x) {
  return x + 2;
}

function fn3(x) {
  return x + 3;
}

function fn4(x) {
  console.log(44);
  return x + 4;
}
var tt = compose2(fn2, fn3, fn4);
```

## 42.洗牌算法 Shuffle Algorithm, 用于随机排列或打乱数组或列表中的元素顺序，以产生随机性

```js
function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    // // 生成 0 到 i 之间的随机索引
    const j = Math.floor(Math.random() * (i - 1));
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
  return arr;
}
shuffleArray([1, 2, 3, 4, 5]);
```

## 43.单例模式

单例模式通俗点说就是：**定义一个类，生成一个实例，并且整个项目仅此这一个实例** 相信大家在项目中都封装使用过 Axios 吧我们会先定义封装一个请求的实例然后暴露出去

```js
// utils/request
class HttpRequest {
   instance: AxiosInstance;
  constructor(options: CreateAxiosOptions) {
    this.instance = axios.create(options)
  }
  get() {...}
  post() {...}
  put() {...}
  delete() {...}
}
// 生成一个实例
const request = new HttpRequest({})

// 全局仅用这么一个请求实例
export default request
```

然后在项目中各处去使用这一个请求实例

```js
import request from 'utils/request';
const fetchData = (url) => {
  return request.get(url);
};
```

## 44.观察者模式

通俗点讲就是：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

我们平时使用的框架 Vue，它的响应式就是基于观察者模式去做的，下面是简单展示一下它的原理

```js
class Subject {
  count: number;
  observers: any[];
  constructor() {
    this.count = 0;
    this.observers = [];
  }
  getCount() {
    return this.count;
  }
  setCount(count: number) {
    // 设置值之后通知更新
    this.count = count;
    this.notify();
  }
  notify() {
    this.observers.forEach((o) => {
      o.update();
    });
  }
  push(o) {
    this.observers.push(o);
  }
}

class Observer {
  constructor(name: string, sub: Subject) {
    this.name = name;
    this.subject = sub;
    this.subject.push(this);
  }
  update() {
    console.log(`${this.name} 变了 ${this.subject.getCount()}`);
  }
}

const sub = new Subject();
// 观察一号
const observer1 = new Observer('一号', sub);
// 观察二号
const observer2 = new Observer('二号', sub);

sub.setCount(1);
// 一号 变了 1
// 二号 变了 1
```

## 45.工厂模式

工厂模式通俗点说就是：更方便地去创建实例

大家开发中应该使用过 axios.create 这个方法吧？这其实就是工厂模式的实践之一

我简单分析一下 axios.create 的原理（不一定跟源码一模一样）,**axios.create**每次返回的都是一个全新的实例

```js
class Axios {}
class Fatory {
  create() {
    return new Axios();
  }
}
var axios = new Fatory();
export default axios;

使用部分;

import axios from 'axios';

// 创建很多实例
const httpRequest1 = axios.create();
const httpRequest2 = axios.create();
```

## 46.装饰器模式

装饰器模式通俗点说就是：定义一个类，在不改这个类的前提下，给这个类拓展功能

```js
class Man {
  say() {
    console.log('我是普通人');
  }
}
class Man2SuperMan {
  man: Man;
  constructor(man) {
    this.man = man;
  }
  say() {
    this.man.say();
    console.log('我变成超人啦！');
  }
}

const man = new Man();
const superMan = new Man2SuperMan(man);
man.say();
// 我是普通人
superMan.man();
// 我是普通人
// 我变成超人啦！
```

## 47.代理模式

代理模式通俗易懂点说就是：**为对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象**

最好的实践场景就是 ES6 Proxy

```js
const handler = {
  get: function (obj, prop) {
    return prop in obj ? obj[prop] : 7;
  },
};

const p = new Proxy({}, handler);
p.a = 1;
p.b = undefined;

console.log(p.a, p.b); // 1, undefined
console.log('c' in p, p.c); // false, 7
```

## 参考

- [面试官不要再问我 axios 了？我能手写简易版的 axios](https://mp.weixin.qq.com/s/nmKU-Z1Ewc75HH0NxgvcCw)
- [一文帮你搞定 90% 的 JS 手写题](https://mp.weixin.qq.com/s/uKPVedfQkgEPYoRUtwyeQQ)
- [前端手写并理解面试常考 code 的思路和运行过程](https://mp.weixin.qq.com/s/Z9tiY0bbpwmEqLEtKmDWOg)
- [前端设计模式](https://mp.weixin.qq.com/s/9UNJG0MJrAsYKjQK4MAoyg)
