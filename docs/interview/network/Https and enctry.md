---
title: HTTPS以及背后的加密原理
order: 5
group:
  order: 2
  title: 网络
  path: /interview/network
nav:
  order: 3
  title: 'interview'
  path: /interview
---

## 为什么需要 https

### http 存在三个弊端：

- 无法保证消息的安全性 **安全性**
- 无法保证消息的完整性和准确性，数据的**完整性**
- 无法保证消息来源的**可靠性**，身份校验

## 基本概念

> 知道摘要/数字签名/数字证书的关系吗 https 中客户端如何拿到服务端的公钥

为了解决 http 中存在的问题，https 采用了一些加解密，数字证书，数字签名的技术来实现。下面先介绍一下这些技术的基本概念

### 加密套件

浏览器和服务器通信之前会先协商，选出它们都支持的加密套件，用来实现安全的通信。[常见加密套件](https://ciphersuite.info/cs/?software=openssl&singlepage=true) 随便拿出一个加密套件举例，如：TLS_DHE_RSA_WITH_AES_128_CCM，就是长这样，代表什么意思呢

Protocol:Tls 协议 Transport Layer Security (TLS)

Key Exchange:密钥交换算法？ Diffie-Hellman Ephemeral (DHE)

Authentication:验证数字签名算法？ Rivest Shamir Adleman algorithm (RSA)

Encryption:加密算法(对称加密) AES AEAD Advanced Encryption Standard with 128bit key in Counter with CBC-MAC mode (AES 128 CCM)

Hash:摘要加密算法 Secure Hash Algorithm 256 (SHA256)

### 对称加密和非对称加密

1.对称加密（共享密匙加密）：客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。(base64 算是对称加密)

常用到的加密算法： 如**AES、DES，以及 AES128**等

2.对称加密优缺点优点： a.对称加密解决了 http 中消息保密性的问题缺点： b.对称加密虽然保证了消息保密性，但是因为客户端和服务器共享一个密匙，这样就使得密匙特别容易泄露。 c.因为密匙泄露风险较高，所以很难保证消息来源的可靠性、消息的完整性和准确性。

3.非对称加密（公有密匙加密）：既然对称加密中，密匙那么容易泄露，那么我们可以采用一种非对称加密的方式来解决。采用非对称加密时，客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见。

使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密。

非对称加密用到的算法主要是：**RSA、ECDHE**

> tls 1.3 已经废弃 RSA,目前主流采用的都是 ECDHE

4.非对称加密优缺点

优点：

a.非对称加密采用公有密匙和私有密匙的方式，解决了 http 中**消息保密性**问题，而且使得私有密匙泄露的风险降低。

b.因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了**消息的来源性**以及**消息的准确性和完整性**。

缺点

c.加密性能相对对称加密会慢几倍，比较消耗系统资源

d.非对称加密需要接受对方的公钥对消息进行加密，但是公钥不是保密的，任何人都阔以拿到，中间人也阔以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是中间服务器的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。

### 混合加密

所谓 “取长补短”，TLS 在加密算法上结合了非对称加密和对称加密，我们这里称之为 “混合加密” 算法，使用**非对称加密(公私钥)**进行**身份验证和共享密钥的协商**，只用一次即可，后续的通信中使用**对称密钥**进行数据的传输。

TLS 实际用的是两种算法的混合加密。通过 **非对称加密算法** 交换 **对称加密算法** 的密钥，交换完成后，再使用对称加密进行加解密传输数据。这样就保证了会话的机密性

> 对称密钥怎么生成的？ 客户端随机数+服务端随机数+预主密钥 + 主密钥 => 会话密钥

混合加密缺点

客户端和服务端交换**公钥**的过程，依然存在被窃听，经典的例子还是中间人攻击，因为公钥在传输的过程是可见的，中间人可以对客户端扮演服务端的角色或者对服务端扮演客户端的角色，依然可以对数据进行篡改，但是服务端无法判别来源是否可靠，问题仍然存在。

> CA 对服务端公钥进行 MD5 或者 SHA_2 加密 => 生成一段单向不可逆的 hash Value CA 用自己的私钥+Hash Value => 数字签名 CA 将数字签名和申请信息整合 =>数字证书摘要算法(单向不可逆) > 数字签名 > 数字证书

### 中间人攻击

中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的**证书校验**是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。

攻击场景如用户在一个未加密的 WiFi 下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

- 常见攻击方式

a.嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具 b.数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。 c.会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。 d.SSL 剥离：HTTPS 是通过 SSL/TLS 进行加密过的，在 SSL 剥离攻击中，会使 SSL/TLS 连接断开，让受保护的 HTTPS，变成不受保护的 HTTP（这对于网站非常致命） e.DNS 欺骗，攻击者往往通过入侵到 DNS 服务器，或者篡改用户本地 hosts 文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器

- 预防方案：

a.用可信的第三方 CA 厂商

b.不下载未知来源的证书，不要去下载一些不安全的文件

c.确认你访问的 URL 是 HTTPS 的，确保网站使用了 SSL，确保禁用一些不安全的 SSL，只开启：TLS1.1，TLS1.2

d.不要使用公用网络发送一些敏感的信息

e.不要去点击一些不安全的连接或者恶意链接或邮件信息

### 非对称加密+对称加密？

既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。请看一下这个过程：

- 某网站拥有用于非对称加密的公钥 A、私钥 A’。
- 浏览器向网站服务器请求，服务器把公钥 A 明文给传输浏览器。
- 浏览器随机生成一个用于对称加密的密钥 X，用公钥 A 加密后传给服务器。
- 服务器拿到后用私钥 A’解密得到密钥 X。
- 这样双方就都拥有密钥 X 了，且别人无法知道它。之后双方所有数据都通过密钥 X 加密解密即可。

完美！HTTPS 基本就是采用了这种方案。完美？还是有漏洞的。再想想看？如果中间人把公钥 A 给调包了呢

如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥 X，这个密钥本身被公钥 A 加密了，只有服务器才有私钥 A’解开它，然而中间人却完全不需要拿到私钥 A’就能干坏事了。请看：

- 某网站有用于非对称加密的公钥 A、私钥 A’。
- 浏览器向网站服务器请求，服务器把公钥 A 明文给传输浏览器。
- 中间人劫持到公钥 A，保存下来，**把数据包中的公钥 A 替换成自己伪造的公钥 B（它当然也拥有公钥 B 对应的私钥 B’）**。
- 浏览器生成一个用于对称加密的密钥 X，用公钥 B（浏览器无法得知公钥被替换了）加密后传给服务器。
- **中间人劫持后用私钥 B’解密得到密钥 X，再用公钥 A 加密后传给服务器**。
- 服务器拿到后用私钥 A’解密得到密钥 X。

这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥 X。根本原因是**浏览器无法确认收到的公钥是不是网站自己的**，因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？解法是什么？如何证明浏览器收到的公钥一定是该网站的公钥？

### 数字证书与数字签名

为了解决**非对称加密**中公匙来源的不安全性。我们可以使用数字证书和数字签名来解决。

网络世界的**公安局**， 即常说的 _CA_，Certificate Authority **证书认证机构**，我们也需要为网站申请**数字证书**。

> CA 就是网络世界的**公安局**举例非常恰当

证书是一个包含版本、序列号、签名算法、颁发者、有效期、服务器公钥等的数字证书文件。我们的网站在使用 HTTPS 之前都会预先向 CA 机构申请一份数字证书，安装到自己的服务器上，之后浏览器发起请求，服务器就可以把这个数字证书返回到浏览器，这个过程中怎么保证数字证书不被修改呢？

公安局在颁发我们的身份证时有一定的防伪技术，同样 CA 在签发证书时也会对证书进行**数字签名**，保证证书的完整性。

#### 摘要算法(MD5/SHA-2,单向不可逆，不需要提供密钥)

摘要算法是一种单向的加密算法，也称为*散列算法*，在加密数据时**不需要提供密钥**，加密之后的数据也不能进行逆向推算。

它能实现对一个大文件加密之后映射为一个小文件，好比一篇文章提取一段摘要，但如果原文发生改变，哪怕是增加或删除一个标点符号再次加密后的结果也会发生完全不同的变化，目前一些常用的摘要算法（**MD5**、SHA-1）被认为存在安全性问题，在 TLS 1.3 版本已经移除了，现在推荐的是 **SHA-2**，例如 SHA256。

CA 机构对明文数据(服务端会自己生成一对密钥，这里明文数据主要包含**服务器公钥**和**企业其他信息**)会做一个摘要算法，生成一段不可逆向解密的 Hash value，这段 Hash value 不能明文传输，避免中间人在修改证书后把摘要算法也修改了。

> 防止了信息被篡改 单向 Hash 算法有一种特点就是单向不可逆的，只要原始内容有一点变化，加密后的数据都将会是千差万别（当然也有很小的可能性会重复）

> 如何验证摘要算法生成的 hash value 可靠？？ 办法：客户端根据加密套件里的同样的摘要算法，然后通过数字证书拿到的服务端公钥+企业信息去生成摘要，对比两个摘要是否一致，如果不一致说明服务端公钥被篡改了

> 数字证书里没有显示摘要信息 只有数字签名或者证书签名信息

> 查看证书的时候 会有一个指纹?是指摘要？ SHA-256: 67 AD D1 16 6B 02 0A E6 1B 8F 5F C9 68 13 C0 4C 2A A5 89 96 07 96 86 55 72 A3 C7 E7 37 61 3D FD SHA-1: A0 53 37 5B FE 84 E8 B7 48 78 2C 7C EE 15 82 7A 6A F5 A4 05

#### 数字签名(证明自己，CA 私钥 + hash value => 数字签名)

数字签名，这个名字在现实世界也是如此，例如我给你一个证明，要证明是我给你的，最有效的办法就是**签名**、**按手印**，这个是没办法伪造的。

CA 也有一对自己的公私钥，结合上面摘要算法生成的 hash value，使用 CA 私钥加上这段 hash value 来生成数字签名，这个**只有对应的公钥即 CA 这边的公钥才可解密数字签名**。

**CA 私钥 + hash value => 数字签名**

> 客户端如何拿到 CA 生成的公钥信息? CA 机构的公钥是不需要传输的，操作系统提供的根证书里会存在）

> 如何验证数字签名的准确性？ 数字证书验证通过，数字签名即准确

> 生成数字签名用到了什么算法？Rivest Shamir Adleman algorithm (RSA) or Pre-Shared Key (PSK)

#### 数字证书

CA 将**数字签名**和我们申请的信息（服务器名称、公钥、主机名、权威机构的名称、信息等）整合到一块，生成数字证书，颁发给服务器。

有了数字证书，客户端和服务端在交互时就可使用**非对称密钥**来协商用于数据加密的**对称加密密钥**了。

> 这句话怎么理解？？？

> 生成数字证书没有用到算法？

![数字证书.png](https://s2.loli.net/2022/05/29/rzCwkO1I5x3fvpe.png)

### 数字证书如何认证以及如何起作用(!!! 非常重要)

服务器在获取到数字证书后，服务器会将数字证书发送给客户端，客户端就需要用**CA 的公匙**解密**数字证书中的数字签名**并验证数字证书的合法性

> 如何获取 CA 里的公钥，思考下

我们的电脑和浏览器中已经内置了一部分权威机构的**根证书**，这些根证书中包含了 CA 的公匙，之所以是根证书，是因为现实生活中，认证中心是分层级的，也就是说有顶级认证中心，也有下面的各个子级的认证中心，是一个树状结构，计算机中内置的是**最顶级机构**的**根证书**，不过不用担心，根证书的公匙在子级也是适用的。

> 如果计算机里的跟证书被伪造呢

#### 数字证书验证

> 数字证书生成：由数字签名和申请信息(服务器相关)生成,

> 数字签名生成：CA 私钥 + hash value 生成，需要 CA 公钥才能解密得到 hash value 信息

> hash value 哈希值生成：算法 SHA(服务器公钥+企业信息)

- 使用 CA 公钥和声明的签名算法对 数字证书中的数字签名进行解密，得到摘要内容 Hash value
- 客户端通过数字证书里的摘要算法，对证书里的服务器公钥生成摘要，**对比摘要**，如果一致说明证书合法，里面的服务器公钥也是正确的，否则就是非法的

证书验证存在一个**证书信任链**的问题

我们向 CA 申请的证书，通常是由**中级证书机构颁发**的。例如，www.nodejs.red 这个域名你会看到它的证书签发者是 “R3”，它是 _Let's Encrypt_ 在 2020 年 11 月 20 日推出的一个免费证书，通过 R3 我们可以找到它的签发者是 “**ISRG Root X1**”，而 “ISRG Root X1” 没有了上级的签发者，现在会认为它是根证书。

看看微信**https://mp.weixin.qq.com/**域名的证书签发者： _DigiCert Secure Site CN CA G3_，这个就是*DigiCert Secure Site CN CA G3*就是中级证书机构颁发机构，在往上找就是 **DigiCert Global Root CA** 这个是**根证书颁发机构** ![link.png](https://s2.loli.net/2022/05/29/lTajCR4GBJPdFZE.png)

网站证书 ->(签发者) 中级证书颁发机构 ->(签发者) 根证书颁发机构根证书颁发机构 ->(验证) 中级证书颁发机构 -> (验证) 网站证书

下图展示的是 www.nodejs.red 这个域名网站的证书链关系。 ![instance.png](https://s2.loli.net/2022/05/29/AF6Rcfu2Wlpm8iD.png)

在我们的操作系统中会预先安装一些权威机构的证书，浏览器信任的是根证书，如果根证书在本地，就用根证书 “ISRG Root X1” 公钥去验证 “ISRG Root X1” 这个中间证书机构是否可信，如果校验通过，再用 “ISRG Root X1” 去验证最终的实体证书 “www.nodejs.red” 是否可信任，如果通过就认为证书 “www.nodejs.red” 是可信的。

证书验证基本上都是这种模式，最终要找到本地安装的根证书，在反向的逐级验证，确认网站的签发者是可信的。如下图所示。 ![CA.png](https://s2.loli.net/2022/05/29/e1QxWZLXFRksYc2.png)

证书认证又分为单向认证和双向认证

- 单向认证：服务器发送证书，客户端验证证书
- 双向认证：服务器和客户端分别提供证书给对方，并互相验证对方的证书

不过大多数 https 服务器都是单向认证，如果服务器需要验证客户端的身份，一般通过用户名、密码、手机验证码等之类的凭证来验证。只有更高级别的要求的系统，比如大额网银转账等，就会提供双向认证的场景，来确保对客户身份提供认证性

#### 数字证书如何起作用

如果服务器返回的证书验证通过，**浏览器**就可获取到数字证书的明文、数字签名信息，做以下操作：

- 用 CA 机构里的公钥（CA 机构的公钥是不需要传输的，操作系统提供的根证书里会存在）去解密数字证书中的**数字签名**(RSA/PSK)，最终客户端 得到数字摘要 **hash value1**
- 客户端用证书里指定的 hash 摘要算法对明文数据(包含**服务器公钥**和**企业其他信息**)做加密,生成一份摘要 **hashCode2**。
- 然后两种比对 如果明文数据未被篡改，hashCode2 应该等于 hashCode1。
- 现在证书是可信的，就可拿到服务器的公钥。(为了得到最初服务器的公钥 真心不容易!!!)

这样客户端安全的从证书中拿到服务器的**公匙**就可以和服务器进行安全的非对称加密通信了。服务器想获得客户端的公匙也可以通过相同方式。

如果证书信息被篡改，没有证书.私钥是不能改签名的(数字签名由摘要+CA 私钥生成)，客户端收到证书之后对原文信息做个签名一比对就知道是否被篡改。

另一个问题，假设：“我们的证书被黑客用合法证书调包呢？”，证书的域名等信息是不能被篡改的，就算黑客调包换成了自己的合法证书，因为域名信息不一样，浏览器请求的时候一对比也可发现问题。

没有绝对的安全，如果黑客把自己的根证书安装在了你的计算机上，那么它就可以签发任意域名的虚假证书了，因此，遇到一些不可信的文件还是不要乱安装的好，保证**根证书**的安全。

## 参考

看了这么多 https 相关的文章，以下两篇文章说的很通透

- [一篇文章读懂 HTTPS 及其背后的加密原理](https://mp.weixin.qq.com/s/3gI8avaaaEaBJjOKitN7Fw)
- [看了很多 HTTPS 原理介绍，这个是最详细的了！](https://mp.weixin.qq.com/s/Kl0D0EorDfqQi2w-tqcVbQ)
- [20 分钟助你拿下 HTTP 和 HTTPS，巩固你的 HTTP 知识体系](https://juejin.cn/post/6994629873985650696#heading-12)
- [彻底搞懂 HTTPS 的加密原理](https://zhuanlan.zhihu.com/p/43789231)
