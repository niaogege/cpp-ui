---
title: TCP/UDP
order: 5
group:
  order: 2
  title: 网络
  path: /interview/network
nav:
  order: 3
  title: 'interview'
  path: /interview
---

## TCP

我们知道 TCP 协议是可靠的，它主要是通过解决如下几个问题来保证可靠性的：乱序/丢包/流控拥塞控制

![OSI.jpg](https://s2.loli.net/2022/05/06/ZvgxF5aq7uL1Owi.jpg)

### TCP 用到的术语解释

- TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。

- Synchronization: 同步 SYN 客户端想和服务端数据同步
- Sequence Number: 记录包的序号，随机生成，作为初始值进行后续判断依据，**序号是根据对方的确认号生成**,TCP 会按照报文字节进行编号，它是用来解决包在网络中**乱序**和**丢包**的问题。

> 这个序号起了很重要的作用，我们都知道 tcp 和 udp 最大的区别在于 tcp 是稳定并且有序的，其中 seq 就可以保证有序，当 A 向 B 发送一个数据包的时候，seq 会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况

- Acknowledgement Number: 确认序列号 SYN+ACK 表示确认同步，**确认号是根据对方的序列号+1 生成的**,是用于向发送方确认已经收到了哪些包，也能用来解决不丢包的问题

> 实际中使用的 ACK，是另一端对对方 seq 的一个回应，一般会把对方给的 seq+1 然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；

- ACK 包
- FIN: finish 结束
- Windows 也叫 Advertised-Windows，也就是著名的滑动窗口，主要是用来解决流控的，实际中用 win 来表示，win 的大小很重要，win 越大的传输越快

### 老生常谈三次握手

![tcpThreehandShake.jpg](https://s2.loli.net/2022/05/06/fkKSp1MQyzsTJCH.png)

TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小等信息。

第一次： SYN 客户端向服务器端发送一个 SYN 请求包，包含客户端使用的端口号和初始序列号 seq=x,并进入 **SYN_SENT** 状态，等待服务器的确认

第二次： SYN+ACK 服务器端收到客户端发送过来的 SYN 请求包后，知道客户端想要建立连接，需要向客户端发送一个 SYN+ACK 报文，包含确认号 ack=x+1 和服务器端的初始序列号 seq=y，此时服务器进入 SYN_RCVD 状态；

第三次： ACK 客户端收到服务器端返回的 SYN 请求包和 ACK 回应包后，需要向服务器端发送确认包(确认号 ack=y+1 和序号 seq=x+1 的 ACK 请求包)，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。

### ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN 为何要动态随机？

ISN 是什么？

答：ISN 全称是 Initial Sequence Number，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号

ISN 是固定不变的吗？

答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 ISN 是动态生成的

### 什么是半连接队列？

答：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### 三次握手过程中，可以携带数据吗？

答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。

对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。

### 四次挥手

![fourHand.jpg](https://s2.loli.net/2022/05/06/2MDX19SnZKT3gRB.jpg)

当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

第一次：ACK+FIN

客户端向服务端发送 ACK+FIN 表示想结束本次的链接，初始序列号 seq=x,确认号 ack=y(确认号+序号会不断递增),客户端进入**FIN_WAIT_1**状态

第二次：ACK 服务器端收到 FIN 包，发出确认包 ACK（ack=x+1），并带上序号 seq=y，服务器端进入了 **CLOSE_WAIT** 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 **FIN_WAIT_2** 状态。

第三次：FIN+ACK 但是服务端可能还有未发送完的数据，此时服务端还再发送一个 ACK+FIN 进行最后的确认，seq=y,ack=x+1,确认号和序号没有改变，此时还没有一来一回,服务器此时进入了 LAST_ACK 状态。

第四次：ACK 客户端收到服务器的 FIN 包后，会向服务端发送 ACK 进行最后的确认(此时自己的序号需要用对方的确认号 seq=x+1，自己的确认号需要用到对方的序列号 seq=y+1),此时客户端就进入了 **TIME_WAIT** 状态。注意此时 TCP 连接还没有释放，必须经过`2*MSL`后，才进入 CLOSED 状态。而服务器端收到客户端的确认包 ACK 后就进入了**CLOSED**状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。

### 问：为什么建立连接握手三次，关闭连接时需要是四次呢？

答：其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。

对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。

### 问：为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？

答：MSL 指的是报文在网络中最大生存时间。在客户端发送确认包 ACK 后，这个 ACK 包是有可能没到达服务端，服务器端如果收不到 ACK 的话需要**重新发送** FIN 包。

所以客户端发送 ACK 后需要留出 2MSL 时间（1.ACK 到达服务器 + 2.服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。

也就是说客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN，说明可以确认服务器已经收到客户端发送的 ACK。

还有第 2 个理由，避免新旧连接混淆。

在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。

你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。

### 为什么是四次挥手而不是三次？

因为服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN。因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN。这就造成了四次挥手。如果是三次挥手会有什么问题？等于说服务端将 ACK 和 FIN 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 FIN 没有到达客户端，从而让客户端不断的重发 FIN。

### 说说半连接队列和 SYN Flood 攻击的关系

三次握手前，服务端的状态从 CLOSED 变为 LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即 SYN 队列和 ACCEPT 队列。

#### 半连接队列

当客户端发送 SYN 到服务端，服务端收到以后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，也就是半连接队列。

#### SYN Flood 攻击原理

SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 SYN。对于服务端而言，会产生两个危险的后果: 处理大量的 SYN 包并返回对应 ACK, 势必有大量连接处于 SYN_RCVD 状态，从而占满整个半连接队列，无法处理正常的请求。由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。如何应对 SYN Flood 攻击？

增加 SYN 连接，也就是增加半连接队列的容量。减少 SYN + ACK 重试次数，避免大量的超时重发。利用 **SYN Cookie** 技术，在服务端接收到 SYN 后不立即分配连接资源，而是根据这个 SYN 计算出一个 Cookie，连同第二次握手回复给客户端，在客户端回复 ACK 的时候带上这个 Cookie 值，服务端验证 Cookie 合法之后才分配连接资源。

### 能不能说一说 TCP 的流量控制

对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。要具体理解流量控制，首先需要了解滑动窗口的概念。

TCP 滑动窗口

TCP 滑动窗口分为两种: 发送窗口和接收窗口。

#### 流量控制过程

这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。

## UDP

### 能不能说一说 TCP 和 UDP 的区别？

首先概括一下基本的区别:

- TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。
- UDP 是一个面向无连接的传输层协议。(就这么简单，其它 TCP 的特性也就没有了)。具体来分析，和 UDP 相比，TCP 有三大核心特性:
- 面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
- 可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。 TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。相应的，UDP 就是无状态, 不可控的。
- 面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

## 参考

- [说一下 HTTP/3 新特性，为什么选择使用 UDP 协议？](https://mp.weixin.qq.com/s/WbNwnlW0C9SAYbn4Yedqnw)
- [淘宝二面，面试官居然把 TCP 三次握手问的这么详细](https://mp.weixin.qq.com/s/BYVzMtbgmKS9QQHvZa3eDQ)

- [(建议收藏)TCP 协议灵魂之问，巩固你的网路底层基础](https://mp.weixin.qq.com/s/hy-X0sY05_UK8G_SB4jXoQ)
