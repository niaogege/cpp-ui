---
title: 装饰器和反射的基础知识
order: 26
group:
  order: 1
  title: js Basic
  path: /interview/js
nav:
  order: 3
  title: 'interview'
  path: /interview
---

- 装饰器基本语法
- 反射 Reflect 的 API 文档 Module/Controller/Inject

## Reflect 基本知识

```ts
declare namespace Reflect {
  function apply(target: Function, thisArgument: any, argumentsList: ArrayLike<any>): any;
  function construct(target: Function, argumentsList: ArrayLike<any>, newTarget?: Function): any;
  function defineProperty(
    target: object,
    propertyKey: PropertyKey,
    attributes: PropertyDescriptor & ThisType<any>,
  ): boolean;
  function deleteProperty(target: object, propertyKey: PropertyKey): boolean;
  function get(target: object, propertyKey: PropertyKey, receiver?: any): any;
  function getOwnPropertyDescriptor(
    target: object,
    propertyKey: PropertyKey,
  ): PropertyDescriptor | undefined;
  function getPrototypeOf(target: object): object | null;
  function has(target: object, propertyKey: PropertyKey): boolean;
  function isExtensible(target: object): boolean;
  function ownKeys(target: object): (string | symbol)[];
  function preventExtensions(target: object): boolean;
  function set(target: object, propertyKey: PropertyKey, value: any, receiver?: any): boolean;
  function setPrototypeOf(target: object, proto: object | null): boolean;
}
```

### Module

```ts
@Module({{
  imports: [],
  controllers: [AppController],
  providers: [AppService],
  exports: [],
}})
class AppModule {}
// @Module源码
const validate_module_keys_util_1 = require("../../utils/validate-module-keys.util");
function Module(metadata) {
    const propsKeys = Object.keys(metadata);
    (0, validate_module_keys_util_1.validateModuleKeys)(propsKeys);
    return (target) => {
        for (const property in metadata) {
            if (metadata.hasOwnProperty(property)) {
                Reflect.defineMetadata(property, metadata[property], target);
            }
        }
    };
}
exports.Module = Module;
```

### Controller

```ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller({
  path: '/cpp',
  host: '127.0.0.1',
})
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

// @Controller
export declare function Controller(options: ControllerOptions): ClassDecorator;
export interface ControllerOptions extends ScopeOptions, VersionOptions {
  path?: string | string[];
  host?: string | RegExp | Array<string | RegExp>;
}
export interface ScopeOptions {
  scope?: Scope;
  durable?: boolean;
}
export declare enum Scope {
  DEFAULT = 0,
  TRANSIENT = 1,
  REQUEST = 2,
}
export interface VersionOptions {
  version?: string;
}
// source
const constants_1 = require('../../constants');
const shared_utils_1 = require('../../utils/shared.utils');
function Controller(prefixOrOptions) {
  const defaultPath = '/';
  const [path, host, scopeOptions, versionOptions] = (0, shared_utils_1.isUndefined)(
    prefixOrOptions,
  )
    ? [defaultPath, undefined, undefined, undefined]
    : (0, shared_utils_1.isString)(prefixOrOptions) || Array.isArray(prefixOrOptions)
    ? [prefixOrOptions, undefined, undefined, undefined]
    : [
        prefixOrOptions.path || defaultPath,
        prefixOrOptions.host,
        { scope: prefixOrOptions.scope, durable: prefixOrOptions.durable },
        Array.isArray(prefixOrOptions.version)
          ? Array.from(new Set(prefixOrOptions.version))
          : prefixOrOptions.version,
      ];
  return (target) => {
    Reflect.defineMetadata(constants_1.CONTROLLER_WATERMARK, true, target);
    Reflect.defineMetadata(constants_1.PATH_METADATA, path, target);
    Reflect.defineMetadata(constants_1.HOST_METADATA, host, target);
    Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, scopeOptions, target);
    Reflect.defineMetadata(constants_1.VERSION_METADATA, versionOptions, target);
  };
}
```

### Injectable

```js
import { Injectable } from '@nestjs/common';

@Injectable({
  scope: 1,
  durable: true,
})
export class AppService {
  getHello(): string {
    return 'Hello World! CPP';
  }
}

// interface
export declare function Injectable(options?: InjectableOptions): ClassDecorator;
export declare function mixin<T>(mixinClass: Type<T>): Type<T>;
export declare type InjectableOptions = ScopeOptions;
// source
function Injectable(options) {
  return (target) => {
    Reflect.defineMetadata(constants_1.INJECTABLE_WATERMARK, true, target);
    Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, options, target);
  };
}
exports.Injectable = Injectable;
function mixin(mixinClass) {
  Object.defineProperty(mixinClass, 'name', {
    value: (0, uuid_1.v4)(),
  });
  Injectable()(mixinClass);
  return mixinClass;
}
exports.mixin = mixin;
```

### Controller 中的@Get 请求

```ts
@Get()
  getHello(): string {
    return this.appService.getHello();
  }
```
