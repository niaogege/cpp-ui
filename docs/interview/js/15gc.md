---
title: 垃圾回收Garbage Collection和数据类型
order: 15
group:
  order: 1
  title: js Basic
  path: /interview/js
nav:
  order: 3
  title: 'interview'
  path: /interview
---

> 又一个高频问答题，如何才能回答点子上当我们谈论垃圾回收的时候，主要谈论的是啥？具体能否结合实际业务说说

## 前置存知识点

### 数据是如何存储的？

基本数据类型用栈存储，引用数据类型用堆存储, 闭包变量是存储在堆内存中的

以下数据类型存储在栈中: boolean/null/undefined/number/string/symbol/bigint 所有的对象数据类型存放在堆中

你可能会问: 为什么不全部用栈来保存呢？

首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能，如果采用栈来存储更加复杂的对象数据，那么切换上下文的开销将变得巨大！

```js
function f(a) {
  console.log(a);
}
function func(a) {
  f(a);
}
func(1);
```

假设用 ESP 指针来保存当前的执行状态，在系统栈中会产生如下的过程：

- 调用 func, 将 func 函数的上下文压栈，ESP 指向栈顶。
- 执行 func，又调用 f 函数，将 f 函数的上下文压栈，ESP 指针上移。
- 执行完 f 函数，将 ESP 下移，f 函数对应的栈顶空间被回收。
- 执行完 func，ESP 下移，func 对应的空间被回收。

### 栈内存和堆内存

JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的

程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃

### 如何回收调用栈中的数据？

ESP：用于记录当前执行状态的指针（称为 ESP）

通过实例代码

```js
function foo() {
  var a = 1;
  var b = { msg: 'hello world' };
  function bar() {
    var c = 2;
    var d = { msg: 'hello juejin' }; // 执行到此处
  }
  bar();
}
foo();
```

执行过程：

- 执行 foo 函数，压入执行栈 call stack，ESP 指向栈顶
- 执行过程遇到 bar 函数，bar 压入执行栈栈顶，ESP 指向往上移
- 执行完 bar 函数，ESP 指向往下移(从 bar 函数上下文移到 foo 函数执行上下文)，bar 函数对应的栈顶空间被回收
- 执行 foo 函数剩下的部分，执行完之后 ESP 往下移，foo 函数对应的空间被回收

因此，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 **ESP** 来销毁该函数保存在栈中的执行上下文。

> 对于栈内存而言，当 ESP 指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。

## 回收策略

### 标记清楚算法 Mark-sweep

此算法分为 **标记** 和 **清除** 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁

#### 如何给变量加上标记？

1.维护进入环境和离开环境两个列表 2.变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记）

引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 **根** 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局 Window 对象、文档 DOM 树 等

#### 执行过程

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

#### 优缺点

- 优点逻辑简单 标记清楚，打标记与不打标记 ，使用一位二进制位就好

- 缺点 1.产生内存碎片，内存空间不连续，出现内存碎片 2.分配速度慢，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢 3.每隔一段时间运行一次 js 引擎暂停去执行 GC

#### 解决

「标记整理（Mark-Compact）算法」 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，**标记整理算法会**将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内

### 引用计数算法 Reference counting

它把 对象是否不再需要 简化定义为 **对象有没有其他对象引用到它**，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，

#### 策略

策略是跟踪记录每个变量值**被使用**的次数

- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1

- 如果同一个值又被赋给另一个变量，那么引用数加 1

- 如果该变量的值被其他的值**覆盖**了，则引用次数减 1

当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

#### 优缺点

- 优点首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾
- 缺点计数器需要占用很大的位置且无法回收循环引用的变量

## 分代内存

代码运行需要内存，V8 内存限制，在 64 位系统下，V8 最多只能分配 1.4G, 在 32 位系统中，最多只能分配 0.7G

![newold.png](https://s2.loli.net/2022/06/02/IMDzGLyANROrxUt.png)

### 为啥会有分代式垃圾回收

如果没有一个机制区分开，垃圾清理算法在每次垃圾回收时都要**检查**内存中所有的对象，每次垃圾回收都会把那些本来就很大/很老的/存活时间长的对象回收掉，但这些并不需要频繁进行清理，相反新/小/存活时间短的对象检查很快 阔以频繁处理

在 V8 中会把堆分为两个区域：

新生代：新生代中存放的是新产生的对象， **生存时间短** 的对象，通常只支持 1 ～ 32M 的容量(在 64 位和 32 位系统下分别为 32MB 和 16MB) 老生代：老生代中存放的存活时间久 **常驻内存** 的对象，支持的容量就比新生代大很多

### 执行流程

不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

- 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

- 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

- 内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片，当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片。(这步其实是可选的，因为有的垃圾回收器不会产生内存碎片).

### 新生代垃圾回收器(副垃圾回收)

#### 分配方式

新生代存的都是生存周期短的对象，分配内存也很容易，只保存**一个指向内存空间的指针**，根据分配对象的大小递增指针就可以了。

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

#### Cheney

![chenny.png](https://s2.loli.net/2022/06/02/T2xep3jgK7I6dsX.png)

新生代中用 Scavenge 算法来处理，在 Scavenge 算法 的具体实现中，主要采用了一种**复制式**的方法即 **Cheney**算法 cheney 算法，堆内存中的新生代区域对半分为使用空间(也被称为 From 区域)和空闲空间(to 区域)，semispace

当开始进行垃圾回收时，新生代垃圾回收器会对使用区(From)中的活动对象做**标记**，标记完成之后将使用区的活动对象**复制**进空闲区(To)并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区.

Scavenge 由于只复制**存活**的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge 的缺点是只能使用新生代区域堆内存的一半，这是由划分空间和复制机制所决定的。

#### 晋升

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理，对象从新生代移动到老生代的过程叫作晋升。晋升条件

- 已经经历过一次 Scavenge 回收。
- To（空闲）空间的内存占用超过 25%。

### 老生代垃圾回收器(主垃圾回收)

在老生代中，存活对象占较大比重，如果继续采用 Scavenge 算法进行管理，就会存在两个问题：

- 由于存活对象较多，复制存活对象的效率会很低
- 采用 Scavenge 算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。

所以，V8 在老生代中主要采用了**Mark-Sweep**和**Mark-Compact**相结合的方式进行垃圾回收。

第一步，进行标记-清除。这个过程在《JavaScript 高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。

第二步：整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

## 涉及到的算法以及其他

### Stop-the-worild 全停顿

V8 是使用 主副垃圾回收器 来进行垃圾回收，不过由于 JavaScript 是运行在 **主线程** 之上的，一旦执行 垃圾回收算法，会阻塞 js 脚步的执行，待垃圾回收完毕后再恢复脚本执行，即 全停顿（Stop-The-World）

> js 引擎和渲染线程互斥 同理 也跟垃圾回收互斥

### Mark-Compact 标记整理算法

为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 就被提出来了。

在 Mark-Sweep 的基础上演变而来的。Mark-Compact 在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存

> 主要用于老生代垃圾回收

> 在 V8 的回收策略中，Mark-Sweep 和 Mark-Compact 两者是结合使用的。

由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，在取舍上，V8 主要使用 Mark-Sweep，在**空间不足以对从新生代中晋升过来的对象进行分配**时，才使用 Mark-Compact。

### Parallel 并行回收(新生代采用)

新生代对象空间就采用并行回收策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收

### Incremental Marking 增量标记算法和惰性清理

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑 交替 进行，直到标记阶段完成，即 **增量标记（Incremental Marking** 算法

> 类似于 React Fiber，交替式更新 交替式标记

增量标记算法，把一个完整的垃圾回收任务 拆分为很多小任务，这些小任务执行时间比较短，可以 穿插 在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务占用主线程而感受到页面的卡顿。

经过增量标记之后，垃圾回收过程对 JS 应用的阻塞时间减少到原来了 1 / 6, 可以看到，这是一个非常成功的改进。

缺点：采用非黑即白的标记策略，在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了(如何暂停和恢复，react fiber 用链表数据解决)

#### 解决：三色标记法(暂停与恢复)

使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

- 白色指的是未被标记的对象
- 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
- 黑色指自身和成员变量皆被标记

#### 懒性清理 Lazy Sweep

增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是**惰性清理**(Lazy Sweeping)

增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 **JavaScript** 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以**按需逐一**进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

### 并发回收(Concurrent)

> 跟 react 并发模式渲染 机制类似？？？

在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢

它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）

## 总结

再说 V8 中 GC 优化，主要采用

并行回收/增量标记和惰性处理/并发回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价较大，所以应该尽量减少垃圾回收：

- 对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为 0，以此来达到清空数组的目的。
- 对 object 进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为 null，尽快被回收。
- 对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

## 内存泄露分析

- 计时器中**引用**没有清除
- 全局变量 (少用全局变量，避免意外产生全局变量)
- 闭包 (使用闭包要及时注意，有 Dom 元素的引用要及时清理)

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing) console.log('hi');
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log(someMessage);
    },
  };
};
setInterval(replaceThing, 1000);
```

- 事件监听

## 参考

- [(2.4w 字,建议收藏)😇 原生 JS 灵魂之问(下), 冲刺 🚀 进阶最后一公里(附个人成长经验分享)](https://juejin.cn/post/6844904004007247880)
- [垃圾回收](https://mp.weixin.qq.com/s/ISId8v-0NZIhfZsfy7cfww)
- [12 张图带你看看 V8 是如何执行和回收 JavaScript 代码的](https://mp.weixin.qq.com/s/2ZqYGSrDT5pmjoy0Gw7S5A)
