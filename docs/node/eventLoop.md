---
title: node和浏览器中的事件循环
order: 1
group:
  title: node
  order: 0
nav:
  order: 5
  title: 'node'
  path: /node
---

JS 的运行机制就是**事件循环**

因为 js 是单线程运行的，在执行代码时，通过将不同函数的**执行上下文**压入执行栈中来保证代码的有序执行。

### 事件循环初探

- 1.首先要知道，JS 分为同步任务和异步任务
- 2.同步任务都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个执行栈

- 3.主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调
- 4.一旦执行栈中的所有同步任务执行完毕(也就是 JS 引擎线程空闲了)，系统就会**检查任务队列是否有事件回调**，将可运行的异步任务(任务队列中的事件回调，**只要任务队列中有事件回调**，就说明可以执行)添加到执行栈中，开始执行

宏任务：js 引擎会将其添加到任务队列（task queue）中，在当前任务执行完毕后按顺序依次执行.宏任务队列**由事件触发线程**维护

微任务：js 引擎也会将其添加到任务队列中，但是微任务的执行在当前宏任务执行结束后立即进行，也就是说微任务具有更高的执行优先级，可以优先于下一个宏任务执行. 微任务队列是由**JS 引擎线程**维护

### JS 执行/运行机制(!!!)

- 1.执行栈执行宏任务(执行栈么有就从事件队列中获取)

- 2.执行过程中遇到微任务，将微任务添加到微任务队列中

- 3.当前宏任务执行完执行栈为空时，查询是否有异步任务(分宏任务和微任务)需要执行，如有则立即依次执行当前微任务队列中的微任务

- 4.当前微任务执行完成之后，开始检查是否有必要渲染，如有需要 则 GUI 线程接管

- 5.渲染完毕后，JS 引擎线程接管，开启下一次事件循环，执行下一个宏任务(从事件队列中获取)

> 死记硬背 也要完全记下来

### 图解完整的事件循环

![Event Loop](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/18/16fb7ae3b678f1ea~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

- 1.首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分

- 2.同步任务会直接进入主线程依次执行

- 3.异步任务会再分为宏任务和微任务

- 4.1 宏任务进入到 Event Table (事件表) 中，并在里面**注册回调函数**，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中,

> 举例 1：AJax 在执行请求时，会在事件队列中添加事件，ajax 请求完毕后，执行栈为空时就会读取事件队列中的事件，执行回调

- 4.2 微任务也会进入到另一个 Event Table (事件表)中，并在里面**注册回调函数**，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中

- 5.当主线程内的任务执行完毕，主线程为空时，会**先检查微任务**的 Event Queue **是否有事件回调**，如果有事件回调，则执行，如果没有就执行下一个宏任务

> 我们不禁要问了，那怎么知道主线程执行栈为空啊？**js 引擎**存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。

- 6.上述过程会不断重复，这就是 Event Loop，比较完整的事件循环

### 通过一个实际案例加强理解

```js
setTimeout(function () {
  console.log('setTimeout');
});

new Promise(function (resolve) {
  console.log('promise');
}).then(function () {
  console.log('then');
});

console.log('console');
```

说说执行过程：

- 这段代码作为宏任务，进入主线程。

- 先遇到 setTimeout，那么将其回调函数注册后分发到**宏任务 Event Queue**

- 接下来遇到了 Promise，new Promise 立即执行，then 函数分发到微任务 Event Queue

- 遇到 console.log()，立即执行

- 好啦，整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 then 在微任务 Event Queue 里面，执行

- ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 Event Queue 开始。我们发现了宏任务 Event Queue 中 setTimeout 对应的回调函数，立即执行。

- 结束

### 为啥要区分宏任务和微任务

宏任务和微任务的区分是为了更好地协调任务的**执行优先级**，提高 JavaScript 的运行效率和代码的可读性

### javascript 的执行和运行

执行和运行有很大的区别，javascript 在不同的环境下，比如 node，浏览器，Ringo 等等，执行方式是不同的。而运行大多指 javascript 解析引擎，是统一的。

### Node 中的事件循环

- 1.Node 会先执行所有类型为 timers 的 MacroTask 宏任务，然后执行所有的 微任务(NextTick 例外)

- 2.进入 poll 阶段，执行几乎所有 宏任务，然后执行所有的 微任务

- 3.再执行所有类型为 check 的 宏任务，然后执行所有的 微任务

- 4.再执行所有类型为 close callbacks 的 宏任务，然后执行所有的 微任务

至此，完成一个 Tick，回到 timers 阶段

……

如此反复，无穷无尽……

## Node 环境下的事件循环机制

## 浏览器环境下的事件循环机制

## 区别

## 参考

- [JS 运行机制](https://juejin.cn/post/6976927131095793678?searchId=20231201210755359B842682307A9F6668)

- [「硬核 JS」一次搞懂 JS 运行机制](https://juejin.cn/post/6844904050543034376?searchId=20231201233712D5595BAB6E2502B738BB)
